#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Predictor ‚Äî —Ñ—É—Ç–±–æ–ª—å–Ω—ã–π –ø—Ä–µ–¥–∏–∫—Ç–æ—Ä —Å –¥–≤—É–º—è –∞–ª–≥–æ—Ä–∏—Ç–º–∞–º–∏ —Ä–∞—Å—á–µ—Ç–∞
1. –¢—Ä–∞–¥–∏—Ü–∏–æ–Ω–Ω—ã–π –∞–ª–≥–æ—Ä–∏—Ç–º (–≥–æ–ª—ã, —Ñ–æ—Ä—ã, Œª + —Ç–æ—Ç–∞–ª—ã –Ω–∞ –≥–æ–ª—ã) - –ù–ï–ô–¢–†–ê–õ–¨–ù–û–ï –ü–û–õ–ï
2. Œª-–∞–ª–≥–æ—Ä–∏—Ç–º (–∞—Ç–∞–∫—É—é—â–∞—è —ç—Ñ—Ñ–µ–∫—Ç–∏–≤–Ω–æ—Å—Ç—å + –ø—Ä–æ–≥–Ω–æ–∑ —É–≥–ª–æ–≤—ã—Ö) - –° –£–ß–Å–¢–û–ú –î–û–ú–ê–®–ù–ï–ì–û –ü–†–ï–ò–ú–£–©–ï–°–¢–í–ê

–û–°–û–ë–ï–ù–ù–û–°–¢–ò:
- –¢—Ä–∞–¥–∏—Ü–∏–æ–Ω–Ω—ã–π: —á–∏—Å—Ç—ã–µ –¥–∞–Ω–Ω—ã–µ (–∫–∞–∫ –Ω–∞ –Ω–µ–π—Ç—Ä–∞–ª—å–Ω–æ–º –ø–æ–ª–µ)
- Œª-–∞–ª–≥–æ—Ä–∏—Ç–º: –ö1 –¥–æ–º–∞—à–Ω—è—è (+0.20 xG), –ö2 –≥–æ—Å—Ç–µ–≤–∞—è (-0.10 xG)
- –î–æ–±–∞–≤–ª–µ–Ω—ã –Ω–æ–≤—ã–µ –º–µ—Ç—Ä–∏–∫–∏: –£–¥–∞—Ä—ã –≤ —Å—Ç–≤–æ—Ä, –ì–æ–ª–µ–≤—ã–µ –º–æ–º–µ–Ω—Ç—ã, –í—Å–µ–≥–æ —É–¥–∞—Ä–æ–≤
"""
from __future__ import annotations
import tkinter as tk
from tkinter import ttk, messagebox, filedialog
import math, os, time
from typing import List, Dict, Optional, Tuple

# ---------------- –ö–û–ù–°–¢–ê–ù–¢–´ –î–û–ú–ê–®–ù–ï–ì–û –ü–†–ï–ò–ú–£–©–ï–°–¢–í–ê ----------------
HOME_ADVANTAGE = {
    'home_xg_boost': 0.20,
    'away_xg_penalty': -0.10,
    'home_corners_boost': 1.05,
    'away_corners_penalty': 0.97
}

# –ö–æ–Ω—Å—Ç–∞–Ω—Ç—ã –¥–ª—è –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏—è Œª –≤ xG
LAMBDA_TO_XG_COEFFS = {
    'base_coef': 1.4,
    'possession_factor_mult': 0.6,
    'efficiency_base': 0.9,
    'max_xg': 3.0
}

# ---------------- –ù–û–í–´–ï –ö–û–≠–§–§–ò–¶–ò–ï–ù–¢–´ –î–õ–Ø –î–û–ü–û–õ–ù–ò–¢–ï–õ–¨–ù–´–• –ú–ï–¢–†–ò–ö ----------------
ENHANCEMENT_FACTORS = {
    'shots_on_target_weight': 0.04,  # +0.04 xG –∑–∞ —É–¥–∞—Ä –≤ —Å—Ç–≤–æ—Ä (—Ä–µ–∞–ª–∏—Å—Ç–∏—á–Ω–æ)
    'goal_chance_weight': 0.12,  # +0.12 xG –∑–∞ –≥–æ–ª–µ–≤–æ–π –º–æ–º–µ–Ω—Ç (—Ä–µ–∞–ª–∏—Å—Ç–∏—á–Ω–æ)
    'total_shots_factor': 0.005,  # –ú–∏–Ω–∏–º–∞–ª—å–Ω–æ–µ –≤–ª–∏—è–Ω–∏–µ
    'max_enhancement_per_match': 1.2,  # –ú–∞–∫—Å–∏–º—É–º +1.2 xG –æ—Ç –Ω–æ–≤—ã—Ö –º–µ—Ç—Ä–∏–∫
    'min_accuracy_for_bonus': 0.25,  # –¢–æ–ª—å–∫–æ –ø—Ä–∏ —Ç–æ—á–Ω–æ—Å—Ç–∏ >25%
}


# ---------------- Helpers ----------------
def safe_float(s):
    try:
        if s is None:
            return None
        st = str(s).strip().replace(',', '.')
        if st == '':
            return None
        return float(st)
    except:
        return None


def poisson_pmf(k: int, mu: float) -> float:
    if mu <= 0:
        return 1.0 if k == 0 else 0.0
    return math.exp(-mu) * (mu ** k) / math.factorial(k)


def poisson_cdf(k: int, mu: float) -> float:
    return sum(poisson_pmf(i, mu) for i in range(0, k + 1))


def prob_ge(k: int, mu: float) -> float:
    if k <= 0:
        return 1.0
    return 1.0 - poisson_cdf(k - 1, mu)


def prob_le(k: int, mu: float) -> float:
    if k < 0:
        return 0.0
    return poisson_cdf(k, mu)


def calculate_corners_prediction(avg_corners: float, avg_possession: float, is_home: bool = True) -> float:
    """–†–∞—Å—Å—á–∏—Ç—ã–≤–∞–µ—Ç –ø—Ä–æ–≥–Ω–æ–∑ —É–≥–ª–æ–≤—ã—Ö –¥–ª—è –∫–æ–º–∞–Ω–¥—ã"""
    base_multiplier = 0.9 if is_home else 0.8
    base_prediction = avg_corners * base_multiplier

    if avg_possession > 60:
        base_prediction = min(base_prediction + 1, 12)
    elif avg_possession < 40:
        base_prediction = max(base_prediction - 1, 1)

    base_prediction = max(1, min(base_prediction, 10))

    if avg_corners > 7.0:
        base_prediction = min(8, base_prediction)
    elif avg_corners < 3.0:
        base_prediction = max(2, base_prediction)

    return base_prediction


def calculate_individual_totals(xg: float) -> Dict[str, float]:
    totals = {}
    totals['–¢–ë 0.5'] = prob_ge(1, xg) * 100
    totals['–¢–ë 1.5'] = prob_ge(2, xg) * 100
    totals['–¢–ë 2.5'] = prob_ge(3, xg) * 100
    totals['–¢–ë 3.5'] = prob_ge(4, xg) * 100

    totals['–¢–ú 0.5'] = 100 - totals['–¢–ë 0.5']
    totals['–¢–ú 1.5'] = 100 - totals['–¢–ë 1.5']
    totals['–¢–ú 2.5'] = 100 - totals['–¢–ë 2.5']
    totals['–¢–ú 3.5'] = 100 - totals['–¢–ë 3.5']

    return totals


def calculate_total_totals(xg_home: float, xg_away: float) -> Dict[str, float]:
    totals = {}
    total_goals = xg_home + xg_away

    totals['–¢–ë 0.5'] = prob_ge(1, total_goals) * 100
    totals['–¢–ë 1.5'] = prob_ge(2, total_goals) * 100
    totals['–¢–ë 2.5'] = prob_ge(3, total_goals) * 100
    totals['–¢–ë 3.5'] = prob_ge(4, total_goals) * 100

    totals['–¢–ú 0.5'] = 100 - totals['–¢–ë 0.5']
    totals['–¢–ú 1.5'] = 100 - totals['–¢–ë 1.5']
    totals['–¢–ú 2.5'] = 100 - totals['–¢–ë 2.5']
    totals['–¢–ú 3.5'] = 100 - totals['–¢–ë 3.5']

    return totals


# ---------------- –§–£–ù–ö–¶–ò–ò –ê–ù–ê–õ–ò–ó–ê –£–ì–õ–û–í–´–• ----------------
def get_detailed_corners_analysis(team1_data: List[Dict], team2_data: List[Dict],
                                  is_home_team1: bool = True, confidence_level: float = 55.0) -> Dict[str, any]:
    """–î–µ—Ç–∞–ª—å–Ω—ã–π –∞–Ω–∞–ª–∏–∑ —É–≥–ª–æ–≤—ã—Ö —Å —Ä–µ–∞–ª–∏—Å—Ç–∏—á–Ω—ã–º–∏ –ø—Ä–æ–≥–Ω–æ–∑–∞–º–∏"""
    # –†–∞—Å—Å—á–∏—Ç—ã–≤–∞–µ–º —Å—Ä–µ–¥–Ω–∏–µ –∑–Ω–∞—á–µ–Ω–∏—è —É–≥–ª–æ–≤—ã—Ö
    team1_avg_corners = sum([d.get('corners', 0) for d in team1_data]) / 3
    team2_avg_corners = sum([d.get('corners', 0) for d in team2_data]) / 3

    # –°—Ä–µ–¥–Ω–µ–µ –≤–ª–∞–¥–µ–Ω–∏–µ –º—è—á–æ–º –¥–ª—è —É—á–µ—Ç–∞ –≤ –ø—Ä–æ–≥–Ω–æ–∑–µ
    team1_avg_possession = sum([d.get('pos', 50) for d in team1_data]) / 3
    team2_avg_possession = sum([d.get('pos', 50) for d in team2_data]) / 3

    # –ü—Ä–æ–≥–Ω–æ–∑ —É–≥–ª–æ–≤—ã—Ö —Å —É—á–µ—Ç–æ–º –¥–æ–º–∞—à–Ω–µ–≥–æ/–≥–æ—Å—Ç–µ–≤–æ–≥–æ —Ñ–∞–∫—Ç–æ—Ä–∞
    team1_prediction = calculate_corners_prediction(team1_avg_corners, team1_avg_possession, is_home=is_home_team1)
    team2_prediction = calculate_corners_prediction(team2_avg_corners, team2_avg_possession, is_home=not is_home_team1)

    # –û–±—â–∏–π –ø—Ä–æ–≥–Ω–æ–∑
    total_corners_prediction = team1_prediction + team2_prediction

    analysis = {
        'total_corners': {
            'prediction': round(total_corners_prediction, 1),
            'team1_prediction': round(team1_prediction, 1),
            'team2_prediction': round(team2_prediction, 1),
            'team1_average': round(team1_avg_corners, 1),
            'team2_average': round(team2_avg_corners, 1)
        },
        'match_type': '',
        'risk_level': '',
        'recommendations': {
            'total': {},
            'team1': {},
            'team2': {},
            'best_overall': ''
        },
        'all_options': []
    }

    # –û–ø—Ä–µ–¥–µ–ª—è–µ–º —Ç–∏–ø –º–∞—Ç—á–∞ –ø–æ —É–≥–ª–æ–≤—ã–º
    if total_corners_prediction < 6.0:
        analysis['match_type'] = "–ù–ò–ó–ö–û–£–ì–õ–û–í–û–ô –º–∞—Ç—á"
        analysis['risk_level'] = "–ù–ò–ó–ö–ò–ô —Ä–∏—Å–∫"
    elif total_corners_prediction < 9.0:
        analysis['match_type'] = "–°–†–ï–î–ù–ï–£–ì–õ–û–í–û–ô –º–∞—Ç—á"
        analysis['risk_level'] = "–£–ú–ï–†–ï–ù–ù–´–ô —Ä–∏—Å–∫"
    else:
        analysis['match_type'] = "–í–´–°–û–ö–û–£–ì–õ–û–í–û–ô –º–∞—Ç—á"
        analysis['risk_level'] = "–í–´–°–û–ö–ò–ô —Ä–∏—Å–∫"

    # –ë–∞–∑–æ–≤–∞—è —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏—è –ø–æ –æ–±—â–µ–º—É —Ç–æ—Ç–∞–ª—É
    thresholds = [4.5, 5.5, 6.5, 7.5, 8.5, 9.5]
    best_threshold = None
    best_prob = 0
    best_type = None

    # –°–æ–±–∏—Ä–∞–µ–º –≤—Å–µ —Ä–µ–∞–ª–∏—Å—Ç–∏—á–Ω—ã–µ –≤–∞—Ä–∏–∞–Ω—Ç—ã
    analysis['all_options'] = []

    for threshold in thresholds:
        prob_over = (1 - poisson_cdf(int(threshold), total_corners_prediction)) * 100
        prob_under = poisson_cdf(int(threshold) - 1, total_corners_prediction) * 100

        # –°–æ—Ö—Ä–∞–Ω—è–µ–º –≤—Å–µ –≤–∞—Ä–∏–∞–Ω—Ç—ã
        analysis['all_options'].append({
            'threshold': threshold,
            'over_prob': prob_over,
            'under_prob': prob_under,
            'over_text': f"–¢–ë {threshold}: {prob_over:.1f}%",
            'under_text': f"–¢–ú {threshold}: {prob_under:.1f}%"
        })

        if prob_over >= confidence_level and prob_over > best_prob:
            best_prob = prob_over
            best_threshold = threshold
            best_type = 'over'
        elif prob_under >= confidence_level and prob_under > best_prob:
            best_prob = prob_under
            best_threshold = threshold
            best_type = 'under'

    if best_threshold:
        bet_type = "–¢–ë" if best_type == 'over' else "–¢–ú"
        analysis['recommendations']['total'] = {
            'recommended_bet': f"{bet_type} {best_threshold} ({best_prob:.1f}%)",
            'probability': best_prob,
            'confidence': "–í–´–°–û–ö–ê–Ø —É–≤–µ—Ä–µ–Ω–Ω–æ—Å—Ç—å" if best_prob >= 70 else "–°–†–ï–î–ù–Ø–Ø —É–≤–µ—Ä–µ–Ω–Ω–æ—Å—Ç—å",
            'justification': f"–û–∂–∏–¥–∞–µ—Ç—Å—è –º–∞—Ç—á —Å–æ {analysis['match_type'].split()[0].lower()} –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ–º —É–≥–ª–æ–≤—ã—Ö | –ü—Ä–æ–≥–Ω–æ–∑ –æ–±—â–µ–≥–æ —Ç–æ—Ç–∞–ª–∞: {total_corners_prediction:.1f} | –°—Ä–µ–¥–Ω–∏–µ –∫–æ–º–∞–Ω–¥: –ö1={team1_avg_corners:.1f}, –ö2={team2_avg_corners:.1f}"
        }

    # –ò–Ω–¥–∏–≤–∏–¥—É–∞–ª—å–Ω—ã–µ —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏ –¥–ª—è –∫–æ–º–∞–Ω–¥
    team1_thresholds = [1.5, 2.5, 3.5, 4.5]
    team2_thresholds = [1.5, 2.5, 3.5, 4.5]

    # –î–ª—è –ö1
    best_team1_prob = 0
    best_team1_threshold = None
    best_team1_type = None

    for threshold in team1_thresholds:
        prob_over = (1 - poisson_cdf(int(threshold), team1_prediction)) * 100
        prob_under = poisson_cdf(int(threshold) - 1, team1_prediction) * 100

        if prob_over >= confidence_level and prob_over > best_team1_prob:
            best_team1_prob = prob_over
            best_team1_threshold = threshold
            best_team1_type = 'over'
        elif prob_under >= confidence_level and prob_under > best_team1_prob:
            best_team1_prob = prob_under
            best_team1_threshold = threshold
            best_team1_type = 'under'

    if best_team1_threshold:
        bet_type = "–¢–ë" if best_team1_type == 'over' else "–¢–ú"
        home_status = "–¥–æ–º–∞—à–Ω—è—è" if is_home_team1 else "–≥–æ—Å—Ç–µ–≤–∞—è"
        strength = "—Å–∏–ª—å–Ω–∞—è" if team1_prediction > team1_avg_corners else "—Å–ª–∞–±–∞—è"
        analysis['recommendations']['team1'] = {
            'recommended_bet': f"{bet_type} {best_team1_threshold} ({best_team1_prob:.1f}%)",
            'probability': best_team1_prob,
            'confidence': "–í–´–°–û–ö–ê–Ø —É–≤–µ—Ä–µ–Ω–Ω–æ—Å—Ç—å" if best_team1_prob >= 70 else "–°–†–ï–î–ù–Ø–Ø —É–≤–µ—Ä–µ–Ω–Ω–æ—Å—Ç—å",
            'justification': f"{home_status.capitalize()} –∫–æ–º–∞–Ω–¥–∞ —Å–æ {strength} –∞—Ç–∞–∫–æ–π (—Å—Ä–µ–¥–Ω–µ–µ: {team1_avg_corners:.1f})"
        }

    # –î–ª—è –ö2
    best_team2_prob = 0
    best_team2_threshold = None
    best_team2_type = None

    for threshold in team2_thresholds:
        prob_over = (1 - poisson_cdf(int(threshold), team2_prediction)) * 100
        prob_under = poisson_cdf(int(threshold) - 1, team2_prediction) * 100

        if prob_over >= confidence_level and prob_over > best_team2_prob:
            best_team2_prob = prob_over
            best_team2_threshold = threshold
            best_team2_type = 'over'
        elif prob_under >= confidence_level and prob_under > best_team2_prob:
            best_team2_prob = prob_under
            best_team2_threshold = threshold
            best_team2_type = 'under'

    if best_team2_threshold:
        bet_type = "–¢–ë" if best_team2_type == 'over' else "–¢–ú"
        home_status = "–¥–æ–º–∞—à–Ω—è—è" if not is_home_team1 else "–≥–æ—Å—Ç–µ–≤–∞—è"
        strength = "—Å–∏–ª—å–Ω–∞—è" if team2_prediction > team2_avg_corners else "—Å–ª–∞–±–∞—è"
        analysis['recommendations']['team2'] = {
            'recommended_bet': f"{bet_type} {best_team2_threshold} ({best_team2_prob:.1f}%)",
            'probability': best_team2_prob,
            'confidence': "–í–´–°–û–ö–ê–Ø —É–≤–µ—Ä–µ–Ω–Ω–æ—Å—Ç—å" if best_team2_prob >= 70 else "–°–†–ï–î–ù–Ø–Ø —É–≤–µ—Ä–µ–Ω–Ω–æ—Å—Ç—å",
            'justification': f"{home_status.capitalize()} –∫–æ–º–∞–Ω–¥–∞ —Å–æ {strength} –∞—Ç–∞–∫–æ–π (—Å—Ä–µ–¥–Ω–µ–µ: {team2_avg_corners:.1f})"
        }

    return analysis


def format_corners_analysis_for_display(analysis: Dict[str, any]) -> List[str]:
    """–§–æ—Ä–º–∞—Ç–∏—Ä—É–µ—Ç –∞–Ω–∞–ª–∏–∑ —É–≥–ª–æ–≤—ã—Ö –¥–ª—è –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è"""
    lines = []

    lines.append("üéØ –î–ï–¢–ê–õ–¨–ù–´–ô –ê–ù–ê–õ–ò–ó –£–ì–õ–û–í–´–•")
    lines.append("=" * 60)

    lines.append("üìä –ü–†–û–ì–ù–û–ó–ò–†–£–ï–ú–´–ï –£–ì–õ–û–í–´–ï:")
    lines.append(
        f"   ‚Ä¢ –ö1: {analysis['total_corners']['team1_prediction']} (—Å—Ä–µ–¥–Ω–µ–µ: {analysis['total_corners']['team1_average']})")
    lines.append(
        f"   ‚Ä¢ –ö2: {analysis['total_corners']['team2_prediction']} (—Å—Ä–µ–¥–Ω–µ–µ: {analysis['total_corners']['team2_average']})")
    lines.append(f"   ‚Ä¢ –í—Å–µ–≥–æ: {analysis['total_corners']['prediction']}")
    lines.append(f"   ‚Ä¢ –¢–∏–ø –º–∞—Ç—á–∞: {analysis['match_type']}")
    lines.append(f"   ‚Ä¢ –£—Ä–æ–≤–µ–Ω—å —Ä–∏—Å–∫–∞: {analysis['risk_level']}")
    lines.append("")

    if analysis['recommendations']['total']:
        rec = analysis['recommendations']['total']
        lines.append("‚≠ê –û–°–ù–û–í–ù–ê–Ø –†–ï–ö–û–ú–ï–ù–î–ê–¶–ò–ê–¶–ò–Ø (–æ–±—â–∏–π —Ç–æ—Ç–∞–ª):")
        lines.append(f"   ‚Ä¢ {rec['recommended_bet']}")
        lines.append(f"   ‚Ä¢ –£–≤–µ—Ä–µ–Ω–Ω–æ—Å—Ç—å: {rec['confidence']}")
        lines.append(f"   ‚Ä¢ –û–±–æ—Å–Ω–æ–≤–∞–Ω–∏–µ: {rec['justification']}")
        lines.append("")

    lines.append("üìà –í–°–ï –†–ï–ê–õ–ò–°–¢–ò–ß–ù–´–ï –í–ê–†–ò–ê–ù–¢–´:")
    for option in analysis['all_options']:
        lines.append(
            f"   {'‚úÖ' if option['over_prob'] >= 55 or option['under_prob'] >= 55 else '   '} {option['over_text']} | {option['under_text']}")
    lines.append("")

    if analysis['recommendations']['team1'] or analysis['recommendations']['team2']:
        lines.append("üë• –ò–ù–î–ò–í–ò–î–£–ê–õ–¨–ù–´–ï –†–ï–ö–û–ú–ï–ù–î–ê–¶–ò–ò:")

        if analysis['recommendations']['team1']:
            rec1 = analysis['recommendations']['team1']
            lines.append(f"   ‚Ä¢ –ö1: {rec1['recommended_bet']}")
            lines.append(f"     –û–±–æ—Å–Ω–æ–≤–∞–Ω–∏–µ: {rec1['justification']}")
            lines.append(f"     –£–≤–µ—Ä–µ–Ω–Ω–æ—Å—Ç—å: {rec1['confidence']}")

        if analysis['recommendations']['team2']:
            rec2 = analysis['recommendations']['team2']
            lines.append(f"   ‚Ä¢ –ö2: {rec2['recommended_bet']}")
            lines.append(f"     –û–±–æ—Å–Ω–æ–≤–∞–Ω–∏–µ: {rec2['justification']}")
            lines.append(f"     –£–≤–µ—Ä–µ–Ω–Ω–æ—Å—Ç—å: {rec2['confidence']}")

    return lines


# ---------------- –ù–û–í–´–ï –§–£–ù–ö–¶–ò–ò –î–õ–Ø –î–û–ü–û–õ–ù–ò–¢–ï–õ–¨–ù–´–• –ú–ï–¢–†–ò–ö ----------------
def calculate_realistic_enhanced_xg(base_xg: float, team_data: List[Dict], is_home: bool = True) -> float:
    """–û–ß–ï–ù–¨ —Ä–µ–∞–ª–∏—Å—Ç–∏—á–Ω–æ–µ —É–ª—É—á—à–µ–Ω–∏–µ xG"""
    enhanced_xg = base_xg

    # –°—Ä–µ–¥–Ω–∏–µ –∑–Ω–∞—á–µ–Ω–∏—è
    avg_shots_on_target = sum([d.get('shots_on_target', 0) for d in team_data]) / 3
    avg_goal_chances = sum([d.get('goal_scoring_chances', 0) for d in team_data]) / 3
    avg_total_shots = sum([d.get('total_shots', 0) for d in team_data]) / 3

    # 1. –û–ß–ï–ù–¨ —Å–∫—Ä–æ–º–Ω—ã–π –±–æ–Ω—É—Å –∑–∞ —É–¥–∞—Ä—ã –≤ —Å—Ç–≤–æ—Ä
    sot_bonus = avg_shots_on_target * ENHANCEMENT_FACTORS['shots_on_target_weight']
    sot_bonus = min(sot_bonus, 0.4)  # –ù–µ –±–æ–ª—å—à–µ +0.4 xG

    # 2. –£–º–µ—Ä–µ–Ω–Ω—ã–π –±–æ–Ω—É—Å –∑–∞ –≥–æ–ª–µ–≤—ã–µ –º–æ–º–µ–Ω—Ç—ã
    gsc_bonus = avg_goal_chances * ENHANCEMENT_FACTORS['goal_chance_weight']
    gsc_bonus = min(gsc_bonus, 0.6)  # –ù–µ –±–æ–ª—å—à–µ +0.6 xG

    # 3. –ú–∏–Ω–∏–º–∞–ª—å–Ω—ã–π –±–æ–Ω—É—Å –∑–∞ –æ–±—â–µ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —É–¥–∞—Ä–æ–≤ (—Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ –≤—ã—Å–æ–∫–∞—è —Ç–æ—á–Ω–æ—Å—Ç—å)
    total_shots_bonus = 0
    if avg_total_shots > 0:
        accuracy = (avg_shots_on_target / avg_total_shots)
        if accuracy > ENHANCEMENT_FACTORS['min_accuracy_for_bonus']:
            total_shots_bonus = avg_total_shots * ENHANCEMENT_FACTORS['total_shots_factor']
            total_shots_bonus = min(total_shots_bonus, 0.2)  # –ù–µ –±–æ–ª—å—à–µ +0.2 xG

    # –°—É–º–º–∞—Ä–Ω–æ–µ —É–ª—É—á—à–µ–Ω–∏–µ
    total_enhancement = sot_bonus + gsc_bonus + total_shots_bonus

    # –ñ–ï–°–¢–ö–û–ï –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–µ —Å–≤–µ—Ä—Ö—É
    total_enhancement = min(total_enhancement, ENHANCEMENT_FACTORS['max_enhancement_per_match'])

    enhanced_xg += total_enhancement

    # –§–∏–Ω–∞–ª—å–Ω—ã–µ –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏—è (—Ñ—É—Ç–±–æ–ª—å–Ω–∞—è —Ä–µ–∞–ª—å–Ω–æ—Å—Ç—å)
    enhanced_xg = max(enhanced_xg, 0.1)

    # –ú–∞–∫—Å–∏–º–∞–ª—å–Ω—ã–µ —Ä–µ–∞–ª–∏—Å—Ç–∏—á–Ω—ã–µ –∑–Ω–∞—á–µ–Ω–∏—è:
    # - –î–æ–º–∞: —Ä–µ–¥–∫–æ >3.5 xG
    # - –ì–æ—Å—Ç–∏: —Ä–µ–¥–∫–æ >3.0 xG
    max_limit = 3.5 if is_home else 3.0
    enhanced_xg = min(enhanced_xg, max_limit)

    # –ï—Å–ª–∏ —É–ª—É—á—à–µ–Ω–∏–µ —Å–ª–∏—à–∫–æ–º —Ä–µ–∑–∫–æ–µ (>50% –æ—Ç –±–∞–∑–æ–≤–æ–≥–æ), —É–º–µ–Ω—å—à–∞–µ–º
    if total_enhancement > base_xg * 0.5:
        enhanced_xg = base_xg * 1.3  # –ú–∞–∫—Å–∏–º—É–º +30%

    return round(enhanced_xg, 2)


def analyze_shot_quality(team_data: List[Dict]) -> Dict[str, any]:
    """–ê–Ω–∞–ª–∏–∑ –∫–∞—á–µ—Å—Ç–≤–∞ —É–¥–∞—Ä–æ–≤ –∫–æ–º–∞–Ω–¥—ã"""
    total_shots_in_box = sum([d.get('shots_in_box', 0) for d in team_data])
    total_shots_out_box = sum([d.get('shots_out_box', 0) for d in team_data])
    total_shots_on_target = sum([d.get('shots_on_target', 0) for d in team_data])
    total_goal_chances = sum([d.get('goal_scoring_chances', 0) for d in team_data])
    total_shots = sum([d.get('total_shots', 0) for d in team_data])

    # –°—Ä–µ–¥–Ω–∏–µ –∑–∞ –º–∞—Ç—á
    avg_shots = total_shots / 3
    avg_shots_on_target = total_shots_on_target / 3
    avg_goal_chances = total_goal_chances / 3

    # –ü—Ä–æ—Ü–µ–Ω—Ç —Ç–æ—á–Ω–æ—Å—Ç–∏
    accuracy = (total_shots_on_target / total_shots * 100) if total_shots > 0 else 0

    # –û—Ü–µ–Ω–∫–∞ –∫–∞—á–µ—Å—Ç–≤–∞
    if accuracy > 40 and avg_goal_chances > 2:
        quality = "–í–´–°–û–ö–ê–Ø"
        description = "–û–ø–∞—Å–Ω—ã–µ –∞—Ç–∞–∫–∏ —Å —Ö–æ—Ä–æ—à–µ–π —Ç–æ—á–Ω–æ—Å—Ç—å—é"
    elif accuracy > 30 and avg_goal_chances > 1:
        quality = "–°–†–ï–î–ù–Ø–Ø"
        description = "–£–º–µ—Ä–µ–Ω–Ω–∞—è —É–≥—Ä–æ–∑–∞ –≤–æ—Ä–æ—Ç"
    else:
        quality = "–ù–ò–ó–ö–ê–Ø"
        description = "–°–ª–∞–±—ã–µ –∏–ª–∏ –Ω–µ—Ç–æ—á–Ω—ã–µ –∞—Ç–∞–∫–∏"

    return {
        'accuracy_percentage': round(accuracy, 1),
        'avg_shots_per_match': round(avg_shots, 1),
        'avg_shots_on_target': round(avg_shots_on_target, 1),
        'avg_goal_chances': round(avg_goal_chances, 1),
        'quality_rating': quality,
        'quality_description': description,
        'danger_index': round((avg_shots_on_target * 1.0) + (avg_goal_chances * 1.5), 1)
    }


def get_match_analysis(p1g, pd, p2g, lambda1, lambda2, xg1, xg2):
    """–ê–Ω–∞–ª–∏–∑ –º–∞—Ç—á–∞ —Å –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ–º —Ñ–∞–≤–æ—Ä–∏—Ç–∞"""
    favorite = None
    if p1g >= 45:
        favorite = "–ö1"
    elif p2g >= 45:
        favorite = "–ö2"

    lambda_diff = abs(lambda1 - lambda2)
    xg_diff = abs(xg1 - xg2)

    analysis_lines = []

    if favorite:
        if favorite == "–ö1":
            if p1g >= 60:
                analysis_lines.append("‚úÖ –ö1 - –Ø–í–ù–´–ô –§–ê–í–û–†–ò–¢")
                analysis_lines.append(f"   ‚Ä¢ –í–µ—Ä–æ—è—Ç–Ω–æ—Å—Ç—å –ø–æ–±–µ–¥—ã –ö1: {p1g:.1f}%")
            elif p1g >= 50:
                analysis_lines.append("‚ö° –ö1 - –õ–ï–ì–ö–ò–ô –§–ê–í–û–†–ò–¢")
                analysis_lines.append(f"   ‚Ä¢ –í–µ—Ä–æ—è—Ç–Ω–æ—Å—Ç—å –ø–æ–±–µ–¥—ã –ö1: {p1g:.1f}%")
            else:
                analysis_lines.append("üìä –ö1 - –ù–ï–ó–ù–ê–ß–ò–¢–ï–õ–¨–ù–´–ô –§–ê–í–û–†–ò–¢")
                analysis_lines.append(f"   ‚Ä¢ –í–µ—Ä–æ—è—Ç–Ω–æ—Å—Ç—å –ø–æ–±–µ–¥—ã –ö1: {p1g:.1f}%")
        else:
            if p2g >= 60:
                analysis_lines.append("‚úÖ –ö2 - –Ø–í–ù–´–ô –§–ê–í–û–†–ò–¢")
                analysis_lines.append(f"   ‚Ä¢ –í–µ—Ä–æ—è—Ç–Ω–æ—Å—Ç—å –ø–æ–±–µ–¥—ã –ö2: {p2g:.1f}%")
            elif p2g >= 50:
                analysis_lines.append("‚ö° –ö2 - –õ–ï–ì–ö–ò–ô –§–ê–í–û–†–ò–¢")
                analysis_lines.append(f"   ‚Ä¢ –í–µ—Ä–æ—è—Ç–Ω–æ—Å—Ç—å –ø–æ–±–µ–¥—ã –ö2: {p2g:.1f}%")
            else:
                analysis_lines.append("üìä –ö2 - –ù–ï–ó–ù–ê–ß–ò–¢–ï–õ–¨–ù–´–ô –§–ê–í–û–†–ò–¢")
                analysis_lines.append(f"   ‚Ä¢ –í–µ—Ä–æ—è—Ç–Ω–æ—Å—Ç—å –ø–æ–±–µ–¥—ã –ö2: {p2g:.1f}%")
    else:
        if pd >= 40:
            analysis_lines.append("‚öñÔ∏è –í–´–°–û–ö–ê–Ø –í–ï–†–û–Ø–¢–ù–û–°–¢–¨ –ù–ò–ß–¨–ï–ô")
            analysis_lines.append(f"   ‚Ä¢ –í–µ—Ä–æ—è—Ç–Ω–æ—Å—Ç—å –Ω–∏—á—å–µ–π: {pd:.1f}%")
        else:
            analysis_lines.append("üéØ –°–ë–ê–õ–ê–ù–°–ò–†–û–í–ê–ù–ù–´–ô –ú–ê–¢–ß –ë–ï–ó –Ø–í–ù–û–ì–û –§–ê–í–û–†–ò–¢–ê")
            analysis_lines.append(f"   ‚Ä¢ –ü1: {p1g:.1f}%, –ù–∏—á—å—è: {pd:.1f}%, –ü2: {p2g:.1f}%")

    if xg1 + xg2 > 3.0:
        analysis_lines.append("‚öΩ –û–ñ–ò–î–ê–ï–¢–°–Ø –ó–†–ï–õ–ò–©–ù–´–ô –ú–ê–¢–ß –° –ë–û–õ–¨–®–ò–ú –ö–û–õ–ò–ß–ï–°–¢–í–û–ú –ì–û–õ–û–í")
    elif xg1 + xg2 < 1.5:
        analysis_lines.append("üõ°Ô∏è –í–ï–†–û–Ø–¢–ï–ù –ù–ò–ó–ö–û–í–ê–ó–Ø–ó–ù–´–ô –ú–ê–¢–ß –° –ú–ê–õ–´–ú –ö–û–õ–ò–ß–ï–°–¢–í–û–ú –ì–û–õ–û–í")

    return "\n".join(analysis_lines)


def get_match_recommendation(p1_prob: float, p2_prob: float, draw_prob: float,
                             team1_quality: Dict, team2_quality: Dict,
                             home_advantage: bool = False) -> str:
    """–ì–µ–Ω–µ—Ä–∞—Ü–∏—è —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏ –ø–æ –∏—Å—Ö–æ–¥—É –º–∞—Ç—á–∞"""
    recommendations = []

    # –û–ø—Ä–µ–¥–µ–ª—è–µ–º —Ñ–∞–≤–æ—Ä–∏—Ç–∞
    if p1_prob > p2_prob and p1_prob > draw_prob:
        favorite = "–ö1"
        favorite_prob = p1_prob
        underdog_prob = p2_prob
    elif p2_prob > p1_prob and p2_prob > draw_prob:
        favorite = "–ö2"
        favorite_prob = p2_prob
        underdog_prob = p1_prob
    else:
        favorite = "–ù–ò–ß–¨–Ø"
        favorite_prob = draw_prob

    # –ê–Ω–∞–ª–∏–∑ –∫–∞—á–µ—Å—Ç–≤–∞ –∞—Ç–∞–∫
    quality_diff = team1_quality['danger_index'] - team2_quality['danger_index']

    if favorite == "–ö1":
        if home_advantage:
            recommendations.append("üè† –ö1 –¥–æ–º–∞—à–Ω—è—è –∫–æ–º–∞–Ω–¥–∞ —Å –ø—Ä–µ–∏–º—É—â–µ—Å—Ç–≤–æ–º –ø–æ–ª—è")

        if team1_quality['quality_rating'] == "–í–´–°–û–ö–ê–Ø":
            recommendations.append("üéØ –ö1 –ø–æ–∫–∞–∑—ã–≤–∞–µ—Ç –í–´–°–û–ö–£–Æ —ç—Ñ—Ñ–µ–∫—Ç–∏–≤–Ω–æ—Å—Ç—å –≤ –∞—Ç–∞–∫–µ")
        elif team1_quality['quality_rating'] == "–ù–ò–ó–ö–ê–Ø":
            recommendations.append("‚ö†Ô∏è  –ù–µ—Å–º–æ—Ç—Ä—è –Ω–∞ —Ñ–∞–≤–æ—Ä–∏—Ç–∏–∑–º, –∞—Ç–∞–∫–∞ –ö1 —Å–ª–∞–±–∞—è")

        if quality_diff > 3:
            recommendations.append("‚ö° –ö1 –∑–Ω–∞—á–∏—Ç–µ–ª—å–Ω–æ –æ–ø–∞—Å–Ω–µ–µ –≤ –∞—Ç–∞–∫–µ")

    elif favorite == "–ö2":
        if not home_advantage:
            recommendations.append("üèÉ –ö2 –≥–æ—Å—Ç–µ–≤–∞—è –∫–æ–º–∞–Ω–¥–∞ (–ø—Ä–µ–æ–¥–æ–ª–µ–≤–∞–µ—Ç –≥–æ—Å—Ç–µ–≤–æ–π —Ñ–∞–∫—Ç–æ—Ä)")

        if team2_quality['quality_rating'] == "–í–´–°–û–ö–ê–Ø":
            recommendations.append("üéØ –ö2 –¥–µ–º–æ–Ω—Å—Ç—Ä–∏—Ä—É–µ—Ç –í–´–°–û–ö–£–Æ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∏–≤–Ω–æ—Å—Ç—å")

        if abs(quality_diff) > 3:
            recommendations.append("‚ö° –ö2 –∏–º–µ–µ—Ç —è–≤–Ω–æ–µ –ø—Ä–µ–∏–º—É—â–µ—Å—Ç–≤–æ –≤ –∫–∞—á–µ—Å—Ç–≤–µ –∞—Ç–∞–∫")

    else:  # –ù–∏—á—å—è
        recommendations.append("‚öñÔ∏è  –°–±–∞–ª–∞–Ω—Å–∏—Ä–æ–≤–∞–Ω–Ω—ã–π –º–∞—Ç—á –±–µ–∑ —è–≤–Ω–æ–≥–æ —Ñ–∞–≤–æ—Ä–∏—Ç–∞")

        if abs(quality_diff) < 1:
            recommendations.append("üìä –ö–æ–º–∞–Ω–¥—ã –∏–º–µ—é—Ç —Å—Ö–æ–∂–µ–µ –∫–∞—á–µ—Å—Ç–≤–æ –∞—Ç–∞–∫")
        else:
            if team1_quality['danger_index'] > team2_quality['danger_index']:
                recommendations.append(f"üìà –ö1 –Ω–µ–º–Ω–æ–≥–æ –æ–ø–∞—Å–Ω–µ–µ ({quality_diff:.1f} –±–∞–ª–ª–æ–≤)")
            else:
                recommendations.append(f"üìà –ö2 –Ω–µ–º–Ω–æ–≥–æ –æ–ø–∞—Å–Ω–µ–µ ({abs(quality_diff):.1f} –±–∞–ª–ª–æ–≤)")

    return " | ".join(recommendations)


def get_final_recommendation_text(pick: str, probability: float,
                                  team1_quality: Dict, team2_quality: Dict,
                                  is_home_team: bool = False) -> str:
    """–ö—Ä–∞—Ç–∫–æ–µ –æ–±–æ—Å–Ω–æ–≤–∞–Ω–∏–µ –∏—Ç–æ–≥–æ–≤–æ–π —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏"""
    if pick == "–ü1":
        if is_home_team:
            base = "–î–æ–º–∞—à–Ω—è—è –∫–æ–º–∞–Ω–¥–∞ —Å –ø—Ä–µ–∏–º—É—â–µ—Å—Ç–≤–æ–º –ø–æ–ª—è"
        else:
            base = "–ö–æ–º–∞–Ω–¥–∞ 1"

        if probability >= 60:
            strength = "—è–≤–Ω—ã–π —Ñ–∞–≤–æ—Ä–∏—Ç"
        elif probability >= 50:
            strength = "–ª–µ–≥–∫–∏–π —Ñ–∞–≤–æ—Ä–∏—Ç"
        else:
            strength = "–Ω–µ–∑–Ω–∞—á–∏—Ç–µ–ª—å–Ω—ã–π —Ñ–∞–≤–æ—Ä–∏—Ç"

        if team1_quality['quality_rating'] == "–í–´–°–û–ö–ê–Ø":
            quality = "–∏–º–µ–µ—Ç –æ–ø–∞—Å–Ω—É—é –∞—Ç–∞–∫—É"
        elif team1_quality['quality_rating'] == "–°–†–ï–î–ù–Ø–Ø":
            quality = "–ø–æ–∫–∞–∑—ã–≤–∞–µ—Ç —É–º–µ—Ä–µ–Ω–Ω—É—é —ç—Ñ—Ñ–µ–∫—Ç–∏–≤–Ω–æ—Å—Ç—å"
        else:
            quality = "–Ω–µ—Å–º–æ—Ç—Ä—è –Ω–∞ —Å–ª–∞–±—É—é –∞—Ç–∞–∫—É"

        return f"{base} {strength} ({probability:.1f}%) {quality}"

    elif pick == "–ü2":
        if not is_home_team:
            base = "–ì–æ—Å—Ç–µ–≤–∞—è –∫–æ–º–∞–Ω–¥–∞ –ø—Ä–µ–æ–¥–æ–ª–µ–≤–∞–µ—Ç —Ñ–∞–∫—Ç–æ—Ä –ø–æ–ª—è"
        else:
            base = "–ö–æ–º–∞–Ω–¥–∞ 2"

        if probability >= 60:
            strength = "—è–≤–Ω—ã–π —Ñ–∞–≤–æ—Ä–∏—Ç"
        elif probability >= 50:
            strength = "–ª–µ–≥–∫–∏–π —Ñ–∞–≤–æ—Ä–∏—Ç"
        else:
            strength = "–Ω–µ–∑–Ω–∞—á–∏—Ç–µ–ª—å–Ω—ã–π —Ñ–∞–≤–æ—Ä–∏—Ç"

        if team2_quality['quality_rating'] == "–í–´–°–û–ö–ê–Ø":
            quality = "–¥–µ–º–æ–Ω—Å—Ç—Ä–∏—Ä—É–µ—Ç –≤—ã—Å–æ–∫—É—é —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∏–≤–Ω–æ—Å—Ç—å"
        elif team2_quality['quality_rating'] == "–°–†–ï–î–ù–Ø–Ø":
            quality = "–ø–æ–∫–∞–∑—ã–≤–∞–µ—Ç —Å—Ç–∞–±–∏–ª—å–Ω—É—é –∏–≥—Ä—É"
        else:
            quality = "–Ω–µ—Å–º–æ—Ç—Ä—è –Ω–∞ —Å–∫—Ä–æ–º–Ω—ã–µ –ø–æ–∫–∞–∑–∞—Ç–µ–ª–∏"

        return f"{base} {strength} ({probability:.1f}%) {quality}"

    else:  # –ù–∏—á—å—è
        if probability >= 40:
            strength = "–≤—ã—Å–æ–∫–∞—è –≤–µ—Ä–æ—è—Ç–Ω–æ—Å—Ç—å"
        elif probability >= 30:
            strength = "—É–º–µ—Ä–µ–Ω–Ω–∞—è –≤–µ—Ä–æ—è—Ç–Ω–æ—Å—Ç—å"
        else:
            strength = "–≤–æ–∑–º–æ–∂–Ω–∞—è"

        diff = abs(team1_quality['danger_index'] - team2_quality['danger_index'])
        if diff < 2:
            balance = "—Å–±–∞–ª–∞–Ω—Å–∏—Ä–æ–≤–∞–Ω–Ω—ã–π –º–∞—Ç—á"
        else:
            balance = "–∫–æ–º–∞–Ω–¥—ã –±–ª–∏–∑–∫–∏ –ø–æ —Å–∏–ª–µ"

        return f"{strength} –Ω–∏—á—å–µ–π ({probability:.1f}%) - {balance}"


# ---------------- Params ----------------
DEFAULT_WEIGHTS = [0.5, 0.33, 0.17]
COEFFS = {
    "alpha_box": 0.12,
    "alpha_out": 0.02,
    "alpha_touches": 0.015,
    "pos_baseline": 50.0
}
DEFAULT_CONFIDENCE = 55.0


# ---------------- –¢–†–ê–î–ò–¶–ò–û–ù–ù–´–ô –ê–õ–ì–û–†–ò–¢–ú ----------------
def weighted_avg(values: List[float], weights: Optional[List[float]] = None) -> float:
    if not values:
        return 0.0
    if weights is None or len(weights) != len(values):
        weights = [1.0 / len(values)] * len(values)
    total = sum(weights)
    if total == 0:
        return 0.0
    return sum(v * w for v, w in zip(values, weights)) / total


def calculate_lambda_traditional(team_stats):
    ud = team_stats['ud']
    kas = team_stats['kas']
    vlad = team_stats['vlad']
    ugl = team_stats['ugl']

    ud_norm = ud / 15.0
    kas_norm = kas / 40.0
    vlad_norm = vlad / 70.0
    ugl_norm = ugl / 10.0

    lambda_base = (0.7 * ud_norm + 0.3 * kas_norm + 0.1 * vlad_norm + 0.05 * ugl_norm)

    ud_kas_ratio = ud / kas if kas > 0 else 0
    correction = 1 - 0.48 * ud_kas_ratio
    correction = max(correction, 0.1)

    lambda_final = lambda_base * correction
    return lambda_final


def calculate_expected_goals_from_stats(team_last3: List[Dict], opp_last3: List[Dict],
                                        weights: Optional[List[float]] = None, coeffs: Optional[Dict] = None) -> float:
    if coeffs is None:
        coeffs = COEFFS
    if weights is None:
        weights = DEFAULT_WEIGHTS

    def wavg(list_of_dicts, field):
        vals = [float(d.get(field, 0) or 0.0) for d in list_of_dicts]
        return weighted_avg(vals, weights)

    avg_pos = wavg(team_last3, 'pos')
    avg_sh_in = wavg(team_last3, 'shots_in_box')
    avg_sh_out = wavg(team_last3, 'shots_out_box')
    avg_touches = wavg(team_last3, 'touches_in_box')
    opp_avg_sh_in = wavg(opp_last3, 'shots_in_box')

    xg_attack = (coeffs['alpha_box'] * avg_sh_in + coeffs['alpha_out'] * avg_sh_out + coeffs[
        'alpha_touches'] * avg_touches)
    pos_factor = (avg_pos / coeffs['pos_baseline']) if coeffs['pos_baseline'] else 1.0
    xg_attack *= pos_factor

    opp_def_proxy = coeffs['alpha_box'] * opp_avg_sh_in
    xg = max(0.0, 0.5 * (xg_attack + opp_def_proxy))

    xg = max(xg, 0.1)
    xg = min(xg, 4.0)

    return xg


def compute_result_probs(xg_home: float, xg_away: float, max_k: int = 12):
    p1 = pd = p2 = 0.0
    probs_h = [poisson_pmf(k, xg_home) for k in range(max_k + 1)]
    probs_a = [poisson_pmf(k, xg_away) for k in range(max_k + 1)]
    rem_h = max(0.0, 1.0 - sum(probs_h))
    rem_a = max(0.0, 1.0 - sum(probs_a))
    probs_h[-1] += rem_h
    probs_a[-1] += rem_a

    for i, ph in enumerate(probs_h):
        for j, pa in enumerate(probs_a):
            p = ph * pa
            if i > j:
                p1 += p
            elif i == j:
                pd += p
            else:
                p2 += p

    s = p1 + pd + p2
    if s > 0:
        p1 /= s
        pd /= s
        p2 /= s

    return p1, pd, p2


def get_top_scores(xg_home: float, xg_away: float, top_n: int = 6):
    scores = []
    max_goals = 7

    for i in range(max_goals + 1):
        for j in range(max_goals + 1):
            p_home = poisson_pmf(i, xg_home)
            p_away = poisson_pmf(j, xg_away)
            scores.append(((i, j), p_home * p_away))

    scores.sort(key=lambda x: x[1], reverse=True)

    total = sum(prob for _, prob in scores[:top_n])
    if total > 0:
        return [((h, a), round(prob / total * 100, 2)) for (h, a), prob in scores[:top_n]]
    return [((h, a), 0.0) for (h, a), _ in scores[:top_n]]


# ---------------- Œª-–ê–õ–ì–û–†–ò–¢–ú ----------------
def calculate_lambda_basic(vlad, ud, kas, ugl):
    ud_norm = ud / 15.0
    kas_norm = kas / 40.0
    vlad_norm = vlad / 70.0
    ugl_norm = ugl / 10.0

    lambda_base = (0.7 * ud_norm + 0.3 * kas_norm + 0.1 * vlad_norm + 0.05 * ugl_norm)

    if kas > 0:
        ud_kas_ratio = ud / kas
    else:
        ud_kas_ratio = 0

    correction = 1 - 0.48 * ud_kas_ratio
    correction = max(correction, 0.1)

    lambda_final = lambda_base * correction
    return lambda_final


def calculate_lambda_with_enhancement(vlad_values, ud_in_shtraf, ud_iz_za_shtraf, ugl_values, kas_values):
    vlad_avg = sum(vlad_values) / 3
    ud_total_avg = sum([ud_in_shtraf[i] + ud_iz_za_shtraf[i] for i in range(3)]) / 3
    kas_avg = sum(kas_values) / 3
    ugl_avg = sum(ugl_values) / 3

    lambda_base = calculate_lambda_basic(vlad_avg, ud_total_avg, kas_avg, ugl_avg)

    third_scores = []
    for i in range(3):
        score = ud_in_shtraf[i] + kas_values[i] * 0.5
        third_scores.append((score, i))

    best_third_idx = max(third_scores, key=lambda x: x[0])[1]

    vlad_best = vlad_values[best_third_idx]
    ud_best = ud_in_shtraf[best_third_idx] + ud_iz_za_shtraf[best_third_idx]
    kas_best = kas_values[best_third_idx]
    ugl_best = ugl_values[best_third_idx]

    lambda_best = calculate_lambda_basic(vlad_best, ud_best, kas_best, ugl_best)
    lambda_enhanced = lambda_base * 0.7 + lambda_best * 0.3

    ud_total = sum(ud_in_shtraf) + sum(ud_iz_za_shtraf)
    ud_iz_za_total = sum(ud_iz_za_shtraf)

    if ud_total > 0:
        long_shot_ratio = ud_iz_za_total / ud_total
        if long_shot_ratio > 0.4:
            lambda_enhanced *= (1 - (long_shot_ratio - 0.4))

    corners_bonus = min(ugl_avg / 5.0, 0.3)
    lambda_enhanced *= (1 + corners_bonus)

    if kas_avg > 0:
        efficiency = ud_total_avg / kas_avg
        balance = (vlad_avg / 100.0) * efficiency
        if balance > 0.6:
            lambda_enhanced *= 0.8

    return lambda_enhanced


def lambda_to_xg_with_home_advantage(lambda_val, vlad, ud_total, kas, is_home=True):
    base_coef = LAMBDA_TO_XG_COEFFS['base_coef']
    possession_factor = 1.0 + ((vlad - 50) / 100.0) * LAMBDA_TO_XG_COEFFS['possession_factor_mult']
    possession_factor = max(0.85, min(possession_factor, 1.15))

    if kas > 4:
        efficiency = LAMBDA_TO_XG_COEFFS['efficiency_base'] + (ud_total / kas * 0.25)
        efficiency = max(0.75, min(efficiency, 1.25))
    else:
        efficiency = LAMBDA_TO_XG_COEFFS['efficiency_base']

    xg_neutral = lambda_val * base_coef * possession_factor * efficiency
    xg_neutral = min(xg_neutral, LAMBDA_TO_XG_COEFFS['max_xg'])

    if is_home:
        xg = xg_neutral + HOME_ADVANTAGE['home_xg_boost']
    else:
        xg = xg_neutral + HOME_ADVANTAGE['away_xg_penalty']

    xg = max(xg, 0.1)
    xg = min(xg, LAMBDA_TO_XG_COEFFS['max_xg'] + 0.2)

    return round(xg, 2), round(xg_neutral, 2)


def predict_match_lambda(team1_data, team2_data):
    lambda1 = calculate_lambda_with_enhancement(
        team1_data['vlad'],
        team1_data['ud_in_shtraf'],
        team1_data['ud_iz_za_shtraf'],
        team1_data['ugl'],
        team1_data['kas']
    )

    lambda2 = calculate_lambda_with_enhancement(
        team2_data['vlad'],
        team2_data['ud_in_shtraf'],
        team2_data['ud_iz_za_shtraf'],
        team2_data['ugl'],
        team2_data['kas']
    )

    vlad1_avg = sum(team1_data['vlad']) / 3
    ud1_total_avg = sum([team1_data['ud_in_shtraf'][i] + team1_data['ud_iz_za_shtraf'][i] for i in range(3)]) / 3
    kas1_avg = sum(team1_data['kas']) / 3

    vlad2_avg = sum(team2_data['vlad']) / 3
    ud2_total_avg = sum([team2_data['ud_in_shtraf'][i] + team2_data['ud_iz_za_shtraf'][i] for i in range(3)]) / 3
    kas2_avg = sum(team2_data['kas']) / 3

    xg1, xg1_neutral = lambda_to_xg_with_home_advantage(lambda1, vlad1_avg, ud1_total_avg, kas1_avg, is_home=True)
    xg2, xg2_neutral = lambda_to_xg_with_home_advantage(lambda2, vlad2_avg, ud2_total_avg, kas2_avg, is_home=False)

    p1g, pd, p2g = compute_result_probs(xg1, xg2)

    if p1g > p2g and p1g > pd:
        recommended_outcome = '–ü1'
    elif p2g > p1g and p2g > pd:
        recommended_outcome = '–ü2'
    else:
        recommended_outcome = '–ù–∏—á—å—è/X'

    top_scores = get_top_scores(xg1, xg2, top_n=6)

    total_goals = xg1 + xg2
    over_2_5_prob = round(sum(poisson_pmf(i, xg1) * poisson_pmf(j, xg2)
                              for i in range(8) for j in range(8) if i + j > 2.5) * 100, 1)
    over_1_5_prob = round(sum(poisson_pmf(i, xg1) * poisson_pmf(j, xg2)
                              for i in range(8) for j in range(8) if i + j > 1.5) * 100, 1)
    under_2_5_prob = 100 - over_2_5_prob
    under_1_5_prob = 100 - over_1_5_prob

    p0_1 = poisson_pmf(0, xg1)
    p0_2 = poisson_pmf(0, xg2)
    btts_prob = max(0.0, 1.0 - p0_1 - p0_2 + p0_1 * p0_2) * 100

    return {
        'lambdas': (round(lambda1, 3), round(lambda2, 3)),
        'expected_goals': (round(xg1, 2), round(xg2, 2)),
        'expected_goals_neutral': (round(xg1_neutral, 2), round(xg2_neutral, 2)),
        'home_advantage_effect': (round(xg1 - xg1_neutral, 2), round(xg2 - xg2_neutral, 2)),
        'outcomes': {'home_win': round(p1g * 100, 1), 'draw': round(pd * 100, 1), 'away_win': round(p2g * 100, 1)},
        'recommended_outcome': recommended_outcome,
        'top_scores': top_scores,
        'exact_score_prediction': f"{top_scores[0][0][0]}:{top_scores[0][0][1]}",
        'total_goals': round(total_goals, 2),
        'over_2_5_prob': over_2_5_prob,
        'over_1_5_prob': over_1_5_prob,
        'under_2_5_prob': under_2_5_prob,
        'under_1_5_prob': under_1_5_prob,
        'btts_prob': round(btts_prob, 1),
        'home_advantage_applied': True
    }


# ---------------- GUI ----------------
class UltraCompactPredictor(tk.Tk):
    def __init__(self):
        super().__init__()
        self.title("XG Score ‚Äî –§—É—Ç–±–æ–ª—å–Ω—ã–π –ø—Ä–µ–¥–∏–∫—Ç–æ—Ä(—Å —É–ª—É—á—à–µ–Ω–Ω—ã–º–∏ –º–µ—Ç—Ä–∏–∫–∞–º–∏)")
        self.geometry("850x650")  # –£–≤–µ–ª–∏—á–∏–ª —Ä–∞–∑–º–µ—Ä –æ–∫–Ω–∞

        self.minsize(800, 600)
        self.configure(bg="black")

        # –®—Ä–∏—Ñ—Ç—ã
        self.header_font = ("Segoe UI", 12, "bold")
        self.input_font = ("Segoe UI", 12, "bold")
        self.output_font = ("Consolas", 13, "bold")
        self.small_font = ("Segoe UI", 9, "bold")
        self.label_font = ("Segoe UI", 8, "bold")

        # –û—Å–Ω–æ–≤–Ω–æ–π –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä
        main_container = tk.Frame(self, bg="black")
        main_container.pack(fill="both", expand=True, padx=8, pady=3)

        main_container.columnconfigure(0, weight=1)
        for i in range(4):
            main_container.rowconfigure(i, weight=1 if i == 3 else 0)

        # ========== –í–í–û–î –î–ê–ù–ù–´–• ==========
        input_frame = tk.Frame(main_container, bg="black")
        input_frame.grid(row=0, column=0, sticky="nsew", pady=(0, 5))

        tk.Label(input_frame, text="–í–í–û–î –î–ê–ù–ù–´–• –ü–û–°–õ–ï–î–ù–ò–• 3 –ú–ê–¢–ß–ï–ô (—Å —É–ª—É—á—à–µ–Ω–Ω—ã–º–∏ –º–µ—Ç—Ä–∏–∫–∞–º–∏)",
                 font=("Segoe UI", 11, "bold"), bg="black", fg="#00FF66").pack(pady=(0, 8))

        teams_container = tk.Frame(input_frame, bg="black")
        teams_container.pack(fill="x", expand=True)

        self._create_extended_input_table(teams_container)

        # ========== –ù–ê–°–¢–†–û–ô–ö–ò ==========
        settings_frame = tk.Frame(main_container, bg="black")
        settings_frame.grid(row=1, column=0, sticky="ew", pady=(3, 5))

        settings_row = tk.Frame(settings_frame, bg="black")
        settings_row.pack(fill="x", expand=True)

        # –ê–ª–≥–æ—Ä–∏—Ç–º
        algo_frame = tk.Frame(settings_row, bg="black")
        algo_frame.pack(side="left", fill="x", expand=True, padx=(0, 15))

        tk.Label(algo_frame, text="–ê–ª–≥–æ—Ä–∏—Ç–º:", font=self.small_font,
                 bg="black", fg="white").pack(anchor="w")

        self.algo_var = tk.StringVar(value="both")

        for text, value in [("–û–±–∞ –∞–ª–≥–æ—Ä–∏—Ç–º–∞", "both"),
                            ("–¢–æ–ª—å–∫–æ —Ç—Ä–∞–¥–∏—Ü–∏–æ–Ω–Ω—ã–π", "traditional"),
                            ("–¢–æ–ª—å–∫–æ Œª-–∞–ª–≥–æ—Ä–∏—Ç–º", "lambda")]:
            rb = tk.Radiobutton(algo_frame, text=text, variable=self.algo_var,
                                value=value, font=("Segoe UI", 9, "bold"), bg="black",
                                fg="white", selectcolor="black", anchor="w")
            rb.pack(anchor="w")

        # –ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ –Ω–æ–≤—ã—Ö –º–µ—Ç—Ä–∏–∫–∞—Ö
        info_frame = tk.Frame(settings_row, bg="black")
        info_frame.pack(side="right", fill="x", expand=True, padx=(15, 0))

        tk.Label(info_frame, text="–ù–û–í–´–ï –ú–ï–¢–†–ò–ö–ò (—É–ª—É—á—à–µ–Ω–Ω–∞—è —Ç–æ—á–Ω–æ—Å—Ç—å):", font=self.small_font,
                 bg="black", fg="#00FF66").pack(anchor="e")

        metric1 = tk.Label(info_frame, text="üéØ –£–¥. –≤ —Å—Ç–≤–æ—Ä: —É–ª—É—á—à–µ–Ω–∏–µ –∫–∞—á–µ—Å—Ç–≤–∞ –∞—Ç–∞–∫–∏",
                           font=("Segoe UI", 8, "bold"), bg="black", fg="#00FF66")
        metric1.pack(anchor="e")

        metric2 = tk.Label(info_frame, text="‚ö° –ì–æ–ª. –º–æ–º–µ–Ω—Ç—ã: —Ä–µ–∞–ª—å–Ω–∞—è —É–≥—Ä–æ–∑–∞ –≤–æ—Ä–æ—Ç",
                           font=("Segoe UI", 8, "bold"), bg="black", fg="#00FF66")
        metric2.pack(anchor="e")

        metric3 = tk.Label(info_frame, text="üìä –í—Å–µ–≥–æ —É–¥.: –∫–æ–Ω—Ç–µ–∫—Å—Ç —ç—Ñ—Ñ–µ–∫—Ç–∏–≤–Ω–æ—Å—Ç–∏",
                           font=("Segoe UI", 8, "bold"), bg="black", fg="#00FF66")
        metric3.pack(anchor="e")

        # ========== –ö–ù–û–ü–ö–ò ==========
        buttons_frame = tk.Frame(main_container, bg="black")
        buttons_frame.grid(row=2, column=0, sticky="ew", pady=(3, 8))

        self.btn_calc = tk.Button(buttons_frame, text="–†–ê–°–°–ß–ò–¢–ê–¢–¨",
                                  font=("Segoe UI", 10, "bold"),
                                  bg="#00FF33", activebackground="#66FF66",
                                  command=self.on_calc, height=1)
        self.btn_calc.pack(side="left", fill="x", expand=True, padx=(0, 3))

        self.btn_reset = tk.Button(buttons_frame, text="–°–ë–†–û–°",
                                   font=("Segoe UI", 10, "bold"),
                                   bg="#FF3333", activebackground="#FF6666",
                                   command=self.on_reset, height=1)
        self.btn_reset.pack(side="left", fill="x", expand=True, padx=3)

        self.btn_save = tk.Button(buttons_frame, text="–°–û–•–†–ê–ù–ò–¢–¨ –û–¢–ß–ï–¢",
                                  font=("Segoe UI", 10, "bold"),
                                  bg="#FF33FF", activebackground="#FF66FF",
                                  command=self.on_save, height=1)
        self.btn_save.pack(side="left", fill="x", expand=True, padx=(3, 0))

        # ========== –†–ï–ó–£–õ–¨–¢–ê–¢–´ ==========
        output_frame = tk.Frame(main_container, bg="black")
        output_frame.grid(row=3, column=0, sticky="nsew")

        output_container = tk.Frame(output_frame, bg="black")
        output_container.pack(fill="both", expand=True)

        output_scrollbar = tk.Scrollbar(output_container)
        output_scrollbar.pack(side="right", fill="y")

        self.output = tk.Text(output_container, height=22, font=self.output_font,
                              bg="#000000", fg="#00FF66", wrap="word",
                              yscrollcommand=output_scrollbar.set)
        self.output.pack(side="left", fill="both", expand=True)
        output_scrollbar.config(command=self.output.yview)
        self.output.configure(state="disabled")

    def _create_extended_input_table(self, parent):
        """–°–æ–∑–¥–∞–µ—Ç —Ä–∞—Å—à–∏—Ä–µ–Ω–Ω—É—é —Ç–∞–±–ª–∏—Ü—É –¥–ª—è –≤–≤–æ–¥–∞ –¥–∞–Ω–Ω—ã—Ö —Å –Ω–æ–≤—ã–º –ø–æ—Ä—è–¥–∫–æ–º —Å—Ç–æ–ª–±—Ü–æ–≤"""
        # –ù–æ–≤—ã–π –ø–æ—Ä—è–¥–æ–∫ —Å—Ç–æ–ª–±—Ü–æ–≤ –∫–∞–∫ –≤ –¢–ó
        headers = ["", "–í–ª–∞–¥–µ–Ω–∏–µ", "–í—Å–µ–≥–æ —É–¥.", "–£–¥. –≤ —Å—Ç–≤–æ—Ä", "–ì–æ–ª. –º–æ–º–µ–Ω.",
                   "–£–≥–ª–æ–≤—ã–µ", "–£–¥ –∏–∑ —à—Ç—Ä—Ñ.", "–£–¥ –∏–∑-–∑–∞ —à—Ç—Ä—Ñ.", "–ö–∞—Å–∞–Ω–∏—è"]

        table_frame = tk.Frame(parent, bg="black")
        table_frame.pack(fill="both", expand=True)

        # –ù–∞—Å—Ç—Ä–∞–∏–≤–∞–µ–º grid –¥–ª—è –ø—Ä–æ–ø–æ—Ä—Ü–∏–æ–Ω–∞–ª—å–Ω–æ–≥–æ —Ä–∞—Å—Ç—è–≥–∏–≤–∞–Ω–∏—è
        table_frame.grid_columnconfigure(0, weight=0, minsize=25)  # –ü–µ—Ä–≤—ã–π —Å—Ç–æ–ª–±–µ—Ü - —Ñ–∏–∫—Å–∏—Ä–æ–≤–∞–Ω–Ω—ã–π
        for col in range(1, len(headers)):
            table_frame.grid_columnconfigure(col, weight=1, minsize=60)  # –û—Å—Ç–∞–ª—å–Ω—ã–µ —Å—Ç–æ–ª–±—Ü—ã —Ä–∞—Å—Ç—è–≥–∏–≤–∞—é—Ç—Å—è

        # –ó–∞–≥–æ–ª–æ–≤–∫–∏
        for col, header in enumerate(headers):
            header_label = tk.Label(table_frame, text=header, font=self.label_font,
                                    bg="black", fg="white", anchor="center",
                                    padx=1, pady=2, wraplength=70, justify="center")
            header_label.grid(row=0, column=col, sticky="nsew", padx=1, pady=1)

        self.team1_entries = []
        self.team2_entries = []

        # –°—Ç–∏–ª—å –ø–æ–ª–µ–π –≤–≤–æ–¥–∞
        entry_style = {
            'font': ("Segoe UI", 10, "bold"),
            'justify': "center",
            'relief': "solid",
            'bd': 1,
            'highlightbackground': "#00FF00",
            'highlightcolor': "#00FF00",
            'highlightthickness': 1,
            'width': 4,
            'insertbackground': "#00FF00"
        }

        # –ö–æ–º–∞–Ω–¥–∞ 1 (–î–æ–º–∞—à–Ω—è—è)
        for row in range(1, 4):
            match_label = tk.Label(table_frame, text=f"–ö1 –ú{row}",
                                   font=("Segoe UI", 9, "bold"), bg="black", fg="#00FF66",
                                   anchor="center", padx=2, pady=2)
            match_label.grid(row=row, column=0, sticky="nsew", padx=1, pady=2)

            row_entries = {}
            # –ù–æ–≤—ã–µ –∏–º–µ–Ω–∞ –ø–æ–ª–µ–π –≤ —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤–∏–∏ —Å –ø–æ—Ä—è–¥–∫–æ–º —Å—Ç–æ–ª–±—Ü–æ–≤
            field_names = ["–≤–ª–∞–¥–µ–Ω–∏–µ", "–≤—Å–µ–≥–æ —É–¥–∞—Ä–æ–≤", "—É–¥ –≤ —Å—Ç–≤–æ—Ä", "–≥–æ–ª–µ–≤—ã–µ –º–æ–º–µ–Ω—Ç—ã",
                           "—É–≥–ª–æ–≤—ã–µ", "—É–¥ –≤ —à—Ç—Ä–∞—Ñ–Ω–æ–π", "—É–¥ –∏–∑-–∑–∞ —à—Ç—Ä–∞—Ñ–Ω–æ–π", "–∫–∞—Å–∞–Ω–∏—è"]

            for col in range(1, 9):
                entry_frame = tk.Frame(table_frame, bg="#00FF00", padx=0, pady=0)
                entry_frame.grid(row=row, column=col, padx=1, pady=2, sticky="nsew")
                entry_frame.grid_propagate(False)  # –û—Ç–∫–ª—é—á–∞–µ–º –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–µ –∏–∑–º–µ–Ω–µ–Ω–∏–µ —Ä–∞–∑–º–µ—Ä–∞

                entry = tk.Entry(entry_frame, **entry_style,
                                 bg="#111111", fg="#00FF66")
                entry.pack(fill="both", expand=True, padx=1, pady=1)

                row_entries[field_names[col - 1]] = entry

            self.team1_entries.append(row_entries)

        # –†–∞–∑–¥–µ–ª–∏—Ç–µ–ª—å
        separator = tk.Frame(table_frame, height=2, bg="#444444")
        separator.grid(row=4, column=0, columnspan=9, sticky="ew", pady=4)

        # –ö–æ–º–∞–Ω–¥–∞ 2 (–ì–æ—Å—Ç–µ–≤–∞—è)
        for row in range(5, 8):
            match_label = tk.Label(table_frame, text=f"–ö2 –ú{row - 4}",
                                   font=("Segoe UI", 9, "bold"), bg="black", fg="#FF6600",
                                   anchor="center", padx=2, pady=2)
            match_label.grid(row=row, column=0, sticky="nsew", padx=1, pady=2)

            row_entries = {}
            field_names = ["–≤–ª–∞–¥–µ–Ω–∏–µ", "–≤—Å–µ–≥–æ —É–¥–∞—Ä–æ–≤", "—É–¥ –≤ —Å—Ç–≤–æ—Ä", "–≥–æ–ª–µ–≤—ã–µ –º–æ–º–µ–Ω—Ç—ã",
                           "—É–≥–ª–æ–≤—ã–µ", "—É–¥ –≤ —à—Ç—Ä–∞—Ñ–Ω–æ–π", "—É–¥ –∏–∑-–∑–∞ —à—Ç—Ä–∞—Ñ–Ω–æ–π", "–∫–∞—Å–∞–Ω–∏—è"]

            for col in range(1, 9):
                entry_frame = tk.Frame(table_frame, bg="#00FF00", padx=0, pady=0)
                entry_frame.grid(row=row, column=col, padx=1, pady=2, sticky="nsew")
                entry_frame.grid_propagate(False)

                entry = tk.Entry(entry_frame, **entry_style,
                                 bg="#111111", fg="#FF6600")
                entry.pack(fill="both", expand=True, padx=1, pady=1)

                row_entries[field_names[col - 1]] = entry

            self.team2_entries.append(row_entries)

        for i in range(1, 8):
            table_frame.rowconfigure(i, weight=0, minsize=40)

    def _collect_extended_table(self, table_entries) -> List[Dict]:
        """–°–±–æ—Ä –¥–∞–Ω–Ω—ã—Ö —Å –Ω–æ–≤—ã–º –ø–æ—Ä—è–¥–∫–æ–º —Å—Ç–æ–ª–±—Ü–æ–≤"""
        data = []
        field_map = {
            '–≤–ª–∞–¥–µ–Ω–∏–µ': 'pos',
            '–≤—Å–µ–≥–æ —É–¥–∞—Ä–æ–≤': 'total_shots',
            '—É–¥ –≤ —Å—Ç–≤–æ—Ä': 'shots_on_target',
            '–≥–æ–ª–µ–≤—ã–µ –º–æ–º–µ–Ω—Ç—ã': 'goal_scoring_chances',
            '—É–≥–ª–æ–≤—ã–µ': 'corners',
            '—É–¥ –≤ —à—Ç—Ä–∞—Ñ–Ω–æ–π': 'shots_in_box',
            '—É–¥ –∏–∑-–∑–∞ —à—Ç—Ä–∞—Ñ–Ω–æ–π': 'shots_out_box',
            '–∫–∞—Å–∞–Ω–∏—è': 'touches_in_box'
        }

        for row_widgets in table_entries:
            row = {}
            for widget_name, entry_widget in row_widgets.items():
                field_name = field_map.get(widget_name, widget_name)
                row[field_name] = safe_float(entry_widget.get()) or 0.0

            # –ó–∞–ø–æ–ª–Ω—è–µ–º –æ—Ç—Å—É—Ç—Å—Ç–≤—É—é—â–∏–µ –ø–æ–ª—è –Ω—É–ª—è–º–∏
            for field in field_map.values():
                if field not in row:
                    row[field] = 0.0

            data.append(row)
        return data

    def _prepare_lambda_data(self, team_data: List[Dict]) -> Dict:
        """–ü–æ–¥–≥–æ—Ç–æ–≤–∫–∞ –¥–∞–Ω–Ω—ã—Ö –¥–ª—è Œª-–∞–ª–≥–æ—Ä–∏—Ç–º–∞"""
        vlad_values = [d['pos'] for d in team_data]
        ud_in_shtraf = [d['shots_in_box'] for d in team_data]
        ud_iz_za_shtraf = [d['shots_out_box'] for d in team_data]
        ugl_values = [d['corners'] for d in team_data]
        kas_values = [d['touches_in_box'] for d in team_data]

        return {
            'vlad': vlad_values,
            'ud_in_shtraf': ud_in_shtraf,
            'ud_iz_za_shtraf': ud_iz_za_shtraf,
            'ugl': ugl_values,
            'kas': kas_values
        }

    def _prepare_lambda_data_traditional(self, team_data: List[Dict]) -> Dict:
        """–ü–æ–¥–≥–æ—Ç–æ–≤–∫–∞ –¥–∞–Ω–Ω—ã—Ö –¥–ª—è —Ç—Ä–∞–¥–∏—Ü–∏–æ–Ω–Ω–æ–≥–æ Œª"""
        vlad_values = [d['pos'] for d in team_data]
        ud_in_shtraf = [d['shots_in_box'] for d in team_data]
        ud_iz_za_shtraf = [d['shots_out_box'] for d in team_data]
        ugl_values = [d['corners'] for d in team_data]
        kas_values = [d['touches_in_box'] for d in team_data]

        vlad_avg = sum(vlad_values) / len(vlad_values)
        total_ud = []
        for i in range(len(vlad_values)):
            total_ud.append(ud_in_shtraf[i] + ud_iz_za_shtraf[i])
        ud_avg = sum(total_ud) / len(total_ud)

        kas_avg = sum(kas_values) / len(kas_values)
        ugl_avg = sum(ugl_values) / len(ugl_values)

        return {
            'ud': ud_avg,
            'kas': kas_avg,
            'vlad': vlad_avg,
            'ugl': ugl_avg
        }

    def _get_lambda_advantage_text(self, lambda1, lambda2):
        if lambda1 == 0 and lambda2 == 0:
            return "–ö–æ–º–∞–Ω–¥—ã –∏–º–µ—é—Ç –Ω—É–ª–µ–≤—É—é –∞—Ç–∞–∫—É—é—â—É—é —ç—Ñ—Ñ–µ–∫—Ç–∏–≤–Ω–æ—Å—Ç—å"

        if lambda1 > lambda2:
            denominator = lambda2 if lambda2 > 0 else 0.001
            advantage_pct = ((lambda1 - lambda2) / denominator * 100)
            return f"–ö1 —Å–∏–ª—å–Ω–µ–µ –ö2 –≤ –∞—Ç–∞–∫–µ –Ω–∞ {advantage_pct:.1f}%"
        elif lambda2 > lambda1:
            denominator = lambda1 if lambda1 > 0 else 0.001
            advantage_pct = ((lambda2 - lambda1) / denominator * 100)
            return f"–ö2 —Å–∏–ª—å–Ω–µ–µ –ö1 –≤ –∞—Ç–∞–∫–µ –Ω–∞ {advantage_pct:.1f}%"
        else:
            return "–ö–æ–º–∞–Ω–¥—ã —Ä–∞–≤–Ω—ã –ø–æ –∞—Ç–∞–∫—É—é—â–µ–π —ç—Ñ—Ñ–µ–∫—Ç–∏–≤–Ω–æ—Å—Ç–∏"

    def _get_exact_score_recommendation(self, top_scores):
        if len(top_scores) < 1:
            return "–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –¥–∞–Ω–Ω—ã—Ö –¥–ª—è –ø—Ä–æ–≥–Ω–æ–∑–∞ —Ç–æ—á–Ω–æ–≥–æ —Å—á–µ—Ç–∞"

        best_score = top_scores[0]
        score_text = f"{best_score[0][0]}:{best_score[0][1]}"
        probability = best_score[1]

        if probability >= 20:
            confidence = "–í–´–°–û–ö–ê–Ø —É–≤–µ—Ä–µ–Ω–Ω–æ—Å—Ç—å"
        elif probability >= 10:
            confidence = "–°–†–ï–î–ù–Ø–Ø —É–≤–µ—Ä–µ–Ω–Ω–æ—Å—Ç—å"
        else:
            confidence = "–ù–ò–ó–ö–ê–Ø —É–≤–µ—Ä–µ–Ω–Ω–æ—Å—Ç—å"

        alternatives = []
        for i in range(1, min(3, len(top_scores))):
            alt_score = top_scores[i]
            alt_text = f"{alt_score[0][0]}:{alt_score[0][1]} ({alt_score[1]}%)"
            alternatives.append(alt_text)

        recommendation = f"–†–µ–∫–æ–º–µ–Ω–¥—É–µ–º—ã–π —Ç–æ—á–Ω—ã–π —Å—á–µ—Ç: {score_text} ({probability}%)\n"
        recommendation += f"–£—Ä–æ–≤–µ–Ω—å —É–≤–µ—Ä–µ–Ω–Ω–æ—Å—Ç–∏: {confidence}\n"

        if alternatives:
            recommendation += f"–ê–ª—å—Ç–µ—Ä–Ω–∞—Ç–∏–≤–Ω—ã–µ –≤–∞—Ä–∏–∞–Ω—Ç—ã: {', '.join(alternatives)}"

        return recommendation

    def _get_input_data_summary(self, team1_data: List[Dict], team2_data: List[Dict]) -> List[str]:
        """–ü–æ–ª—É—á–µ–Ω–∏–µ —Å–≤–æ–¥–∫–∏ –≤–≤–µ–¥–µ–Ω–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö –¥–ª—è –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è –≤ –ø—Ä–æ–≥–Ω–æ–∑–µ"""
        lines = []
        lines.append("=" * 80)
        lines.append("–í–í–ï–î–ï–ù–ù–´–ï –î–ê–ù–ù–´–ï –î–õ–Ø –ê–ù–ê–õ–ò–ó–ê (–ø–æ—Å–ª–µ–¥–Ω–∏–µ 3 –º–∞—Ç—á–∞)")
        lines.append("=" * 80)

        # –ö–æ–º–∞–Ω–¥–∞ 1 –¥–∞–Ω–Ω—ã–µ
        lines.append("\nüìä –î–ê–ù–ù–´–ï –ö–û–ú–ê–ù–î–´ 1 (–î–æ–º–∞—à–Ω—è—è):")
        headers = ["–ú–∞—Ç—á", "–í–ª–∞–¥", "–í—Å–µ–≥–æ —É–¥.", "–í —Å—Ç–≤–æ—Ä", "–ì–æ–ª.–º–æ–º.", "–£–≥–ª.", "–£–¥.–≤ —à—Ç—Ä.", "–£–¥.–∏–∑-–∑–∞", "–ö–∞—Å–∞–Ω–∏—è"]
        lines.append("   " + " | ".join(headers))
        lines.append("   " + "-" * 70)

        for i, match in enumerate(team1_data, 1):
            match_data = [
                f"–ú{i}",
                f"{match.get('pos', 0):.0f}",
                f"{match.get('total_shots', 0):.0f}",
                f"{match.get('shots_on_target', 0):.0f}",
                f"{match.get('goal_scoring_chances', 0):.0f}",
                f"{match.get('corners', 0):.0f}",
                f"{match.get('shots_in_box', 0):.0f}",
                f"{match.get('shots_out_box', 0):.0f}",
                f"{match.get('touches_in_box', 0):.0f}"
            ]
            lines.append("   " + " | ".join(match_data))

        # –°—Ä–µ–¥–Ω–∏–µ –∫–æ–º–∞–Ω–¥—ã 1
        avg_team1 = {
            'pos': sum([d.get('pos', 0) for d in team1_data]) / 3,
            'total_shots': sum([d.get('total_shots', 0) for d in team1_data]) / 3,
            'shots_on_target': sum([d.get('shots_on_target', 0) for d in team1_data]) / 3,
            'goal_scoring_chances': sum([d.get('goal_scoring_chances', 0) for d in team1_data]) / 3,
            'corners': sum([d.get('corners', 0) for d in team1_data]) / 3,
            'shots_in_box': sum([d.get('shots_in_box', 0) for d in team1_data]) / 3,
            'shots_out_box': sum([d.get('shots_out_box', 0) for d in team1_data]) / 3,
            'touches_in_box': sum([d.get('touches_in_box', 0) for d in team1_data]) / 3
        }

        lines.append("\n   –°–†–ï–î–ù–ò–ï –ö1 –∑–∞ 3 –º–∞—Ç—á–∞:")
        avg_data = [
            f"{avg_team1['pos']:.1f}",
            f"{avg_team1['total_shots']:.1f}",
            f"{avg_team1['shots_on_target']:.1f}",
            f"{avg_team1['goal_scoring_chances']:.1f}",
            f"{avg_team1['corners']:.1f}",
            f"{avg_team1['shots_in_box']:.1f}",
            f"{avg_team1['shots_out_box']:.1f}",
            f"{avg_team1['touches_in_box']:.1f}"
        ]
        lines.append("   " + " | ".join(avg_data))

        # –ö–æ–º–∞–Ω–¥–∞ 2 –¥–∞–Ω–Ω—ã–µ
        lines.append("\nüìä –î–ê–ù–ù–´–ï –ö–û–ú–ê–ù–î–´ 2 (–ì–æ—Å—Ç–µ–≤–∞—è):")
        lines.append("   " + " | ".join(headers))
        lines.append("   " + "-" * 70)

        for i, match in enumerate(team2_data, 1):
            match_data = [
                f"–ú{i}",
                f"{match.get('pos', 0):.0f}",
                f"{match.get('total_shots', 0):.0f}",
                f"{match.get('shots_on_target', 0):.0f}",
                f"{match.get('goal_scoring_chances', 0):.0f}",
                f"{match.get('corners', 0):.0f}",
                f"{match.get('shots_in_box', 0):.0f}",
                f"{match.get('shots_out_box', 0):.0f}",
                f"{match.get('touches_in_box', 0):.0f}"
            ]
            lines.append("   " + " | ".join(match_data))

        # –°—Ä–µ–¥–Ω–∏–µ –∫–æ–º–∞–Ω–¥—ã 2
        avg_team2 = {
            'pos': sum([d.get('pos', 0) for d in team2_data]) / 3,
            'total_shots': sum([d.get('total_shots', 0) for d in team2_data]) / 3,
            'shots_on_target': sum([d.get('shots_on_target', 0) for d in team2_data]) / 3,
            'goal_scoring_chances': sum([d.get('goal_scoring_chances', 0) for d in team2_data]) / 3,
            'corners': sum([d.get('corners', 0) for d in team2_data]) / 3,
            'shots_in_box': sum([d.get('shots_in_box', 0) for d in team2_data]) / 3,
            'shots_out_box': sum([d.get('shots_out_box', 0) for d in team2_data]) / 3,
            'touches_in_box': sum([d.get('touches_in_box', 0) for d in team2_data]) / 3
        }

        lines.append("\n   –°–†–ï–î–ù–ò–ï –ö2 –∑–∞ 3 –º–∞—Ç—á–∞:")
        avg_data = [
            f"{avg_team2['pos']:.1f}",
            f"{avg_team2['total_shots']:.1f}",
            f"{avg_team2['shots_on_target']:.1f}",
            f"{avg_team2['goal_scoring_chances']:.1f}",
            f"{avg_team2['corners']:.1f}",
            f"{avg_team2['shots_in_box']:.1f}",
            f"{avg_team2['shots_out_box']:.1f}",
            f"{avg_team2['touches_in_box']:.1f}"
        ]
        lines.append("   " + " | ".join(avg_data))

        # –°—Ä–∞–≤–Ω–µ–Ω–∏–µ —Å—Ä–µ–¥–Ω–∏—Ö
        lines.append("\nüìà –°–†–ê–í–ù–ï–ù–ò–ï –°–†–ï–î–ù–ò–• –ü–û–ö–ê–ó–ê–¢–ï–õ–ï–ô:")
        lines.append("   " + "=" * 60)
        lines.append("   –ü–æ–∫–∞–∑–∞—Ç–µ–ª—å           –ö1 (–î–æ–º–∞)   –ö2 (–ì–æ—Å—Ç–∏)   –†–∞–∑–Ω–∏—Ü–∞")
        lines.append("   " + "-" * 60)

        comparisons = [
            ("–í–ª–∞–¥–µ–Ω–∏–µ (%)", avg_team1['pos'], avg_team2['pos']),
            ("–í—Å–µ–≥–æ —É–¥–∞—Ä–æ–≤", avg_team1['total_shots'], avg_team2['total_shots']),
            ("–£–¥–∞—Ä—ã –≤ —Å—Ç–≤–æ—Ä", avg_team1['shots_on_target'], avg_team2['shots_on_target']),
            ("–ì–æ–ª–µ–≤—ã–µ –º–æ–º–µ–Ω—Ç—ã", avg_team1['goal_scoring_chances'], avg_team2['goal_scoring_chances']),
            ("–£–≥–ª–æ–≤—ã–µ", avg_team1['corners'], avg_team2['corners']),
            ("–£–¥. –≤ —à—Ç—Ä–∞—Ñ–Ω–æ–π", avg_team1['shots_in_box'], avg_team2['shots_in_box']),
            ("–£–¥. –∏–∑-–∑–∞ —à—Ç—Ä–∞—Ñ–Ω–æ–π", avg_team1['shots_out_box'], avg_team2['shots_out_box']),
            ("–ö–∞—Å–∞–Ω–∏—è –≤ —à—Ç—Ä–∞—Ñ–Ω–æ–π", avg_team1['touches_in_box'], avg_team2['touches_in_box']),
        ]

        for name, val1, val2 in comparisons:
            diff = val1 - val2
            diff_sign = "+" if diff > 0 else ""
            lines.append(f"   {name:<20} {val1:>9.1f} {val2:>12.1f} {diff_sign:>7}{diff:.1f}")

        lines.append("\n")

        return lines

    def on_calc(self):
        conf = DEFAULT_CONFIDENCE
        algorithm = self.algo_var.get()

        # –°–±–æ—Ä –¥–∞–Ω–Ω—ã—Ö —Å –Ω–æ–≤—ã–º–∏ –º–µ—Ç—Ä–∏–∫–∞–º–∏
        team1_data = self._collect_extended_table(self.team1_entries)
        team2_data = self._collect_extended_table(self.team2_entries)

        lines = []

        # –î–æ–±–∞–≤–ª—è–µ–º –≤–≤–µ–¥–µ–Ω–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ –≤ –Ω–∞—á–∞–ª–æ –ø—Ä–æ–≥–Ω–æ–∑–∞
        input_summary = self._get_input_data_summary(team1_data, team2_data)
        lines.extend(input_summary)

        lines.append("=" * 80)
        lines.append("–§–£–¢–ë–û–õ–¨–ù–´–ô –ü–†–ï–î–ò–ö–¢–û–† - –£–õ–£–ß–®–ï–ù–ù–´–ô –ê–ù–ê–õ–ò–ó")
        lines.append("=" * 80)
        lines.append("")

        # –ê–Ω–∞–ª–∏–∑ –∫–∞—á–µ—Å—Ç–≤–∞ —É–¥–∞—Ä–æ–≤ (–¥–ª—è –æ–±–æ–∏—Ö –∞–ª–≥–æ—Ä–∏—Ç–º–æ–≤)
        team1_quality = analyze_shot_quality(team1_data)
        team2_quality = analyze_shot_quality(team2_data)

        lines.append("üìä –ö–ê–ß–ï–°–¢–í–û –ê–¢–ê–ö–ò –ö–û–ú–ê–ù–î:")
        lines.append(f"   –ö1: {team1_quality['quality_rating']} - {team1_quality['quality_description']}")
        lines.append(f"      –¢–æ—á–Ω–æ—Å—Ç—å: {team1_quality['accuracy_percentage']}% | "
                     f"–£–¥. –≤ —Å—Ç–≤–æ—Ä: {team1_quality['avg_shots_on_target']:.1f} | "
                     f"–ì–æ–ª. –º–æ–º–µ–Ω—Ç—ã: {team1_quality['avg_goal_chances']:.1f}")
        lines.append(f"   –ö2: {team2_quality['quality_rating']} - {team2_quality['quality_description']}")
        lines.append(f"      –¢–æ—á–Ω–æ—Å—Ç—å: {team2_quality['accuracy_percentage']}% | "
                     f"–£–¥. –≤ —Å—Ç–≤–æ—Ä: {team2_quality['avg_shots_on_target']:.1f} | "
                     f"–ì–æ–ª. –º–æ–º–µ–Ω—Ç—ã: {team2_quality['avg_goal_chances']:.1f}")
        lines.append("")

        # --- –¢–†–ê–î–ò–¶–ò–û–ù–ù–´–ô –ê–õ–ì–û–†–ò–¢–ú ---
        if algorithm in ["both", "traditional"]:
            lines.append("‚îÄ" * 40)
            lines.append("üìà –¢–†–ê–î–ò–¶–ò–û–ù–ù–´–ô –ê–õ–ì–û–†–ò–¢–ú (–ù–ï–ô–¢–†–ê–õ–¨–ù–û–ï –ü–û–õ–ï)")
            lines.append("‚îÄ" * 40)
            lines.append("   üéØ –ò—Å–ø–æ–ª—å–∑—É—é—Ç—Å—è –ß–ò–°–¢–´–ï –¥–∞–Ω–Ω—ã–µ (–±–µ–∑ —É–ª—É—á—à–µ–Ω–∏–π –æ—Ç –Ω–æ–≤—ã—Ö –º–µ—Ç—Ä–∏–∫)")
            lines.append("")

            # –ß–ò–°–¢–´–ï xG (–ë–ï–ó —É–ª—É—á—à–µ–Ω–∏–π –æ—Ç –Ω–æ–≤—ã—Ö –º–µ—Ç—Ä–∏–∫) - –∫–∞–∫ –Ω–∞ –Ω–µ–π—Ç—Ä–∞–ª—å–Ω–æ–º –ø–æ–ª–µ
            xg1_pure = calculate_expected_goals_from_stats(team1_data, team2_data, DEFAULT_WEIGHTS, COEFFS)
            xg2_pure = calculate_expected_goals_from_stats(team2_data, team1_data, DEFAULT_WEIGHTS, COEFFS)

            # –ù–ï –ø—Ä–∏–º–µ–Ω—è–µ–º —É–ª—É—á—à–µ–Ω–∏—è –¥–ª—è —Ç—Ä–∞–¥–∏—Ü–∏–æ–Ω–Ω–æ–≥–æ –∞–ª–≥–æ—Ä–∏—Ç–º–∞
            xg1_trad = xg1_pure  # –ß–∏—Å—Ç—ã–π xG –¥–ª—è –ö1
            xg2_trad = xg2_pure  # –ß–∏—Å—Ç—ã–π xG –¥–ª—è –ö2

            # –ò—Å–ø–æ–ª—å–∑—É–µ–º –ß–ò–°–¢–´–ï xG –¥–ª—è —Ä–∞—Å—á–µ—Ç–æ–≤
            p1g, pd, p2g = compute_result_probs(xg1_trad, xg2_trad)
            pick_match = "–ü1" if p1g > p2g and p1g > pd else ("–ü2" if p2g > p1g and p2g > pd else "–ù–∏—á—å—è/X")

            top_scores_trad = get_top_scores(xg1_trad, xg2_trad, top_n=6)
            total_totals = calculate_total_totals(xg1_trad, xg2_trad)
            indiv_totals_team1 = calculate_individual_totals(xg1_trad)
            indiv_totals_team2 = calculate_individual_totals(xg2_trad)

            # –¢—Ä–∞–¥–∏—Ü–∏–æ–Ω–Ω—ã–π Œª (–ë–ï–ó —É–ª—É—á—à–µ–Ω–∏–π)
            team1_stats = self._prepare_lambda_data_traditional(team1_data)
            team2_stats = self._prepare_lambda_data_traditional(team2_data)
            lambda1_trad = calculate_lambda_traditional(team1_stats)
            lambda2_trad = calculate_lambda_traditional(team2_stats)

            lines.append("üéØ –†–ï–ö–û–ú–ï–ù–î–ê–¶–ò–Ø –ü–û –ò–°–•–û–î–£:")
            lines.append(f"   ‚Ä¢ {pick_match}")
            lines.append(f"   ‚Ä¢ –ü1: {p1g * 100:.1f}% | –ù–∏—á—å—è: {pd * 100:.1f}% | –ü2: {p2g * 100:.1f}%")
            lines.append("")

            lines.append("üí° –û–ë–û–°–ù–û–í–ê–ù–ò–ï –†–ï–ö–û–ú–ï–ù–î–ê–¶–ò–ò:")
            recommendation = get_match_recommendation(p1g * 100, p2g * 100, pd * 100,
                                                      team1_quality, team2_quality,
                                                      home_advantage=False)
            lines.append(f"   {recommendation}")
            lines.append("")

            # –í —Ç—Ä–∞–¥–∏—Ü–∏–æ–Ω–Ω–æ–º: –ß–ò–°–¢–´–ï xG
            lines.append("üìä –°–¢–ê–¢–ò–°–¢–ò–ö–ê XG (–ß–ò–°–¢–´–ï –¥–∞–Ω–Ω—ã–µ):")
            lines.append(f"   ‚Ä¢ –ß–∏—Å—Ç—ã–π xG: –ö1={xg1_trad:.2f} | –ö2={xg2_trad:.2f}")
            lines.append(f"   ‚Ä¢ –°–æ–≤–æ–∫—É–ø–Ω—ã–π —Ç–æ—Ç–∞–ª: {xg1_trad + xg2_trad:.2f}")
            lines.append("   ‚Ä¢ –†–∞—Å—Å—á–∏—Ç–∞–Ω—ã –Ω–∞ –æ—Å–Ω–æ–≤–µ –≤–ª–∞–¥–µ–Ω–∏—è, —É–¥–∞—Ä–æ–≤, –∫–∞—Å–∞–Ω–∏–π, —É–≥–ª–æ–≤—ã—Ö")
            lines.append("   ‚Ä¢ –ë–ï–ó —É—á–µ—Ç–∞ —É–¥–∞—Ä–æ–≤ –≤ —Å—Ç–≤–æ—Ä, –≥–æ–ª–µ–≤—ã—Ö –º–æ–º–µ–Ω—Ç–æ–≤ –∏ –≤—Å–µ—Ö —É–¥–∞—Ä–æ–≤")
            lines.append("")

            lines.append("‚ö° –ê–¢–ê–ö–£–Æ–©–ê–Ø –≠–§–§–ï–ö–¢–ò–í–ù–û–°–¢–¨ (Œª):")
            lines.append(f"   ‚Ä¢ –ö1: Œª = {lambda1_trad:.3f}")
            lines.append(f"   ‚Ä¢ –ö2: Œª = {lambda2_trad:.3f}")
            lines.append(f"   ‚Ä¢ {self._get_lambda_advantage_text(lambda1_trad, lambda2_trad)}")
            lines.append("")

            # –ê–Ω–∞–ª–∏–∑ –º–∞—Ç—á–∞
            lines.append(get_match_analysis(p1g * 100, pd * 100, p2g * 100, lambda1_trad, lambda2_trad, xg1_trad,
                                            xg2_trad))
            lines.append("")

            lines.append("üìä –¢–û–¢–ê–õ–´ –ì–û–õ–û–í:")
            for key in ['–¢–ë 0.5', '–¢–ë 1.5', '–¢–ë 2.5', '–¢–ë 3.5',
                        '–¢–ú 0.5', '–¢–ú 1.5', '–¢–ú 2.5', '–¢–ú 3.5']:
                if key in total_totals:
                    lines.append(f"   ‚Ä¢ {key}: {total_totals[key]:.1f}%")
            lines.append("")

            lines.append("üìä –ò–ù–î–ò–í–ò–î–£–ê–õ–¨–ù–´–ï –¢–û–¢–ê–õ–´ –ì–û–õ–û–í:")
            lines.append(
                f"   ‚Ä¢ –¢–ë 0.5: –ö1({indiv_totals_team1['–¢–ë 0.5']:.1f}%)  –ö2({indiv_totals_team2['–¢–ë 0.5']:.1f}%)")
            lines.append(
                f"   ‚Ä¢ –¢–ë 1.5: –ö1({indiv_totals_team1['–¢–ë 1.5']:.1f}%)  –ö2({indiv_totals_team2['–¢–ë 1.5']:.1f}%)")
            lines.append(
                f"   ‚Ä¢ –¢–ë 2.5: –ö1({indiv_totals_team1['–¢–ë 2.5']:.1f}%)  –ö2({indiv_totals_team2['–¢–ë 2.5']:.1f}%)")
            lines.append(
                f"   ‚Ä¢ –¢–ë 3.5: –ö1({indiv_totals_team1['–¢–ë 3.5']:.1f}%)  –ö2({indiv_totals_team2['–¢–ë 3.5']:.1f}%)")
            lines.append(
                f"   ‚Ä¢ –¢–ú 0.5: –ö1({indiv_totals_team1['–¢–ú 0.5']:.1f}%)  –ö2({indiv_totals_team2['–¢–ú 0.5']:.1f}%)")
            lines.append(
                f"   ‚Ä¢ –¢–ú 1.5: –ö1({indiv_totals_team1['–¢–ú 1.5']:.1f}%)  –ö2({indiv_totals_team2['–¢–ú 1.5']:.1f}%)")
            lines.append(
                f"   ‚Ä¢ –¢–ú 2.5: –ö1({indiv_totals_team1['–¢–ú 2.5']:.1f}%)  –ö2({indiv_totals_team2['–¢–ú 2.5']:.1f}%)")
            lines.append(
                f"   ‚Ä¢ –¢–ú 3.5: –ö1({indiv_totals_team1['–¢–ú 3.5']:.1f}%)  –ö2({indiv_totals_team2['–¢–ú 3.5']:.1f}%)")
            lines.append("")

            # BTTS
            p0_1 = poisson_pmf(0, xg1_trad)
            p0_2 = poisson_pmf(0, xg2_trad)
            btts_prob = max(0.0, 1.0 - p0_1 - p0_2 + p0_1 * p0_2) * 100

            lines.append(f"‚öΩ –û–ë–ê –ó–ê–ë–¨–Æ–¢ (BTTS): {btts_prob:.1f}% ‚Üí "
                         f"{'–î–∞' if btts_prob >= conf else '–ù–µ—Ç'}")
            lines.append("")

            lines.append("üéØ –ü–†–û–ì–ù–û–ó –¢–û–ß–ù–û–ì–û –°–ß–ï–¢–ê:")
            lines.append("   –¢–æ–ø-6 –Ω–∞–∏–±–æ–ª–µ–µ –≤–µ—Ä–æ—è—Ç–Ω—ã—Ö —Å—á–µ—Ç–æ–≤:")
            for i, ((h, a), prob) in enumerate(top_scores_trad, 1):
                lines.append(f"   {i}. {h}:{a} - {prob:.2f}%")
            lines.append("")

            lines.append("üí° –†–ï–ö–û–ú–ï–ù–î–ê–¶–ò–Ø –ü–û –¢–û–ß–ù–û–ú–£ –°–ß–ï–¢–£:")
            exact_recommendation = self._get_exact_score_recommendation(top_scores_trad)
            for line in exact_recommendation.split('\n'):
                lines.append(f"   {line}")
            lines.append("")

            # –î–æ–±–∞–≤–ª—è–µ–º –∞–Ω–∞–ª–∏–∑ —É–≥–ª–æ–≤—ã—Ö –¥–ª—è —Ç—Ä–∞–¥–∏—Ü–∏–æ–Ω–Ω–æ–≥–æ –∞–ª–≥–æ—Ä–∏—Ç–º–∞
            corners_analysis_trad = get_detailed_corners_analysis(
                team1_data, team2_data, is_home_team1=True, confidence_level=conf
            )
            corners_lines_trad = format_corners_analysis_for_display(corners_analysis_trad)
            lines.extend(corners_lines_trad)
            lines.append("")

        # --- Œª-–ê–õ–ì–û–†–ò–¢–ú ---
        if algorithm in ["both", "lambda"]:
            lines.append("‚îÄ" * 40)
            lines.append("üî¨ Œª-–ê–õ–ì–û–†–ò–¢–ú (–° –î–û–ú–ê–®–ù–ò–ú –ü–†–ï–ò–ú–£–©–ï–°–¢–í–û–ú)")
            lines.append("‚îÄ" * 40)
            lines.append("   üè† –ö1: –¥–æ–º–∞—à–Ω—è—è (+0.20 xG) | üèÉ –ö2: –≥–æ—Å—Ç–µ–≤–∞—è (-0.10 xG)")
            lines.append("   üéØ –ò—Å–ø–æ–ª—å–∑—É—é—Ç—Å—è –£–õ–£–ß–®–ï–ù–ù–´–ï –¥–∞–Ω–Ω—ã–µ (—Å –Ω–æ–≤—ã–º–∏ –º–µ—Ç—Ä–∏–∫–∞–º–∏)")
            lines.append("")

            team1_lambda_data = self._prepare_lambda_data(team1_data)
            team2_lambda_data = self._prepare_lambda_data(team2_data)

            lambda_prediction = predict_match_lambda(team1_lambda_data, team2_lambda_data)

            # –ü–æ–ª—É—á–∞–µ–º –±–∞–∑–æ–≤—ã–µ xG –∏–∑ Œª-–∞–ª–≥–æ—Ä–∏—Ç–º–∞
            xg1_lambda_neutral = lambda_prediction['expected_goals_neutral'][0]
            xg2_lambda_neutral = lambda_prediction['expected_goals_neutral'][1]
            xg1_lambda_with_field = lambda_prediction['expected_goals'][0]
            xg2_lambda_with_field = lambda_prediction['expected_goals'][1]

            # –ü—Ä–∏–º–µ–Ω—è–µ–º —É–ª—É—á—à–µ–Ω–∏—è –æ—Ç –Ω–æ–≤—ã—Ö –º–µ—Ç—Ä–∏–∫ –¢–û–õ–¨–ö–û –≤ Œª-–∞–ª–≥–æ—Ä–∏—Ç–º–µ
            xg1_lambda_enhanced = calculate_realistic_enhanced_xg(xg1_lambda_with_field, team1_data, is_home=True)
            xg2_lambda_enhanced = calculate_realistic_enhanced_xg(xg2_lambda_with_field, team2_data, is_home=False)

            # –ü–µ—Ä–µ—Å—á–∏—Ç—ã–≤–∞–µ–º —Å –£–õ–£–ß–®–ï–ù–ù–´–ú–ò xG
            p1g_lambda, pd_lambda, p2g_lambda = compute_result_probs(xg1_lambda_enhanced, xg2_lambda_enhanced)

            if p1g_lambda > p2g_lambda and p1g_lambda > pd_lambda:
                lambda_recommended = '–ü1'
            elif p2g_lambda > p1g_lambda and p2g_lambda > pd_lambda:
                lambda_recommended = '–ü2'
            else:
                lambda_recommended = '–ù–∏—á—å—è/X'

            # –†–∞—Å—á–µ—Ç—ã –¥–ª—è –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è
            total_totals_lambda = calculate_total_totals(xg1_lambda_enhanced, xg2_lambda_enhanced)
            indiv_totals_team1_lambda = calculate_individual_totals(xg1_lambda_enhanced)
            indiv_totals_team2_lambda = calculate_individual_totals(xg2_lambda_enhanced)

            lines.append("üéØ –†–ï–ö–û–ú–ï–ù–î–ê–¶–ò–Ø –ü–û –ò–°–•–û–î–£:")
            lines.append(f"   ‚Ä¢ {lambda_recommended}")
            lines.append(
                f"   ‚Ä¢ –ü1: {p1g_lambda * 100:.1f}% | –ù–∏—á—å—è: {pd_lambda * 100:.1f}% | –ü2: {p2g_lambda * 100:.1f}%")
            lines.append("")

            lines.append("üí° –û–ë–û–°–ù–û–í–ê–ù–ò–ï –†–ï–ö–û–ú–ï–ù–î–ê–¶–ò–ò:")
            lambda_recommendation = get_match_recommendation(p1g_lambda * 100, p2g_lambda * 100, pd_lambda * 100,
                                                             team1_quality, team2_quality,
                                                             home_advantage=True)
            lines.append(f"   {lambda_recommendation}")
            lines.append("")

            lines.append("‚ö° –ê–¢–ê–ö–£–Æ–©–ê–Ø –≠–§–§–ï–ö–¢–ò–í–ù–û–°–¢–¨ (Œª):")
            lines.append(f"   ‚Ä¢ –ö1: Œª = {lambda_prediction['lambdas'][0]}")
            lines.append(f"   ‚Ä¢ –ö2: Œª = {lambda_prediction['lambdas'][1]}")
            lines.append(
                f"   ‚Ä¢ {self._get_lambda_advantage_text(lambda_prediction['lambdas'][0], lambda_prediction['lambdas'][1])}")
            lines.append("")

            # –í Œª: –ø–æ–∫–∞–∑—ã–≤–∞–µ–º –£–õ–£–ß–®–ï–ù–ù–´–ï xG
            lines.append("üìä –°–¢–ê–¢–ò–°–¢–ò–ö–ê XG (—Å —É–ª—É—á—à–µ–Ω–∏—è–º–∏ –æ—Ç –Ω–æ–≤—ã—Ö –º–µ—Ç—Ä–∏–∫):")
            lines.append(f"   ‚Ä¢ Œª-–±–∞–∑–æ–≤—ã–π: –ö1={xg1_lambda_neutral:.2f} | –ö2={xg2_lambda_neutral:.2f}")
            lines.append(f"   ‚Ä¢ Œª-—Å –ø–æ–ª–µ–º: –ö1={xg1_lambda_with_field:.2f} | –ö2={xg2_lambda_with_field:.2f}")
            lines.append(f"   ‚Ä¢ Œª-–£–õ–£–ß–®–ï–ù–ù–´–ô: –ö1={xg1_lambda_enhanced:.2f} | –ö2={xg2_lambda_enhanced:.2f}")
            lines.append("   ‚Ä¢ –≠—Ñ—Ñ–µ–∫—Ç –ø–æ–ª—è: –ö1(+0.20) | –ö2(-0.10)")
            lines.append("   ‚Ä¢ –£–ª—É—á—à–µ–Ω–∏—è –æ—Ç –Ω–æ–≤—ã—Ö –º–µ—Ç—Ä–∏–∫: –î–∞ (+—É–¥–∞—Ä—ã –≤ —Å—Ç–≤–æ—Ä, +–≥–æ–ª–µ–≤—ã–µ –º–æ–º–µ–Ω—Ç—ã, +—Ç–æ—á–Ω–æ—Å—Ç—å)")
            lines.append("")

            # –ê–Ω–∞–ª–∏–∑ –º–∞—Ç—á–∞ –¥–ª—è Œª
            lines.append(get_match_analysis(p1g_lambda * 100, pd_lambda * 100, p2g_lambda * 100,
                                            lambda_prediction['lambdas'][0], lambda_prediction['lambdas'][1],
                                            xg1_lambda_enhanced, xg2_lambda_enhanced))
            lines.append("")

            lines.append("üìä –¢–û–¢–ê–õ–´ –ì–û–õ–û–í:")
            for key in ['–¢–ë 0.5', '–¢–ë 1.5', '–¢–ë 2.5', '–¢–ë 3.5',
                        '–¢–ú 0.5', '–¢–ú 1.5', '–¢–ú 2.5', '–¢–ú 3.5']:
                if key in total_totals_lambda:
                    lines.append(f"   ‚Ä¢ {key}: {total_totals_lambda[key]:.1f}%")
            lines.append("")

            lines.append("üìä –ò–ù–î–ò–í–ò–î–£–ê–õ–¨–ù–´–ï –¢–û–¢–ê–õ–´ –ì–û–õ–û–í:")
            lines.append(
                f"   ‚Ä¢ –¢–ë 0.5: –ö1({indiv_totals_team1_lambda['–¢–ë 0.5']:.1f}%)  –ö2({indiv_totals_team2_lambda['–¢–ë 0.5']:.1f}%)")
            lines.append(
                f"   ‚Ä¢ –¢–ë 1.5: –ö1({indiv_totals_team1_lambda['–¢–ë 1.5']:.1f}%)  –ö2({indiv_totals_team2_lambda['–¢–ë 1.5']:.1f}%)")
            lines.append(
                f"   ‚Ä¢ –¢–ë 2.5: –ö1({indiv_totals_team1_lambda['–¢–ë 2.5']:.1f}%)  –ö2({indiv_totals_team2_lambda['–¢–ë 2.5']:.1f}%)")
            lines.append(
                f"   ‚Ä¢ –¢–ë 3.5: –ö1({indiv_totals_team1_lambda['–¢–ë 3.5']:.1f}%)  –ö2({indiv_totals_team2_lambda['–¢–ë 3.5']:.1f}%)")
            lines.append(
                f"   ‚Ä¢ –¢–ú 0.5: –ö1({indiv_totals_team1_lambda['–¢–ú 0.5']:.1f}%)  –ö2({indiv_totals_team2_lambda['–¢–ú 0.5']:.1f}%)")
            lines.append(
                f"   ‚Ä¢ –¢–ú 1.5: –ö1({indiv_totals_team1_lambda['–¢–ú 1.5']:.1f}%)  –ö2({indiv_totals_team2_lambda['–¢–ú 1.5']:.1f}%)")
            lines.append(
                f"   ‚Ä¢ –¢–ú 2.5: –ö1({indiv_totals_team1_lambda['–¢–ú 2.5']:.1f}%)  –ö2({indiv_totals_team2_lambda['–¢–ú 2.5']:.1f}%)")
            lines.append(
                f"   ‚Ä¢ –¢–ú 3.5: –ö1({indiv_totals_team1_lambda['–¢–ú 3.5']:.1f}%)  –ö2({indiv_totals_team2_lambda['–¢–ú 3.5']:.1f}%)")
            lines.append("")

            # BTTS –¥–ª—è Œª
            p0_1_lambda = poisson_pmf(0, xg1_lambda_enhanced)
            p0_2_lambda = poisson_pmf(0, xg2_lambda_enhanced)
            btts_prob_lambda = max(0.0, 1.0 - p0_1_lambda - p0_2_lambda + p0_1_lambda * p0_2_lambda) * 100

            lines.append(f"‚öΩ –û–ë–ê –ó–ê–ë–¨–Æ–¢ (BTTS): {btts_prob_lambda:.1f}% ‚Üí "
                         f"{'–î–∞' if btts_prob_lambda >= conf else '–ù–µ—Ç'}")
            lines.append("")

            # –¢–æ—á–Ω—ã–µ —Å—á–µ—Ç–∞ –Ω–∞ –£–õ–£–ß–®–ï–ù–ù–´–• xG
            top_scores_lambda = get_top_scores(xg1_lambda_enhanced, xg2_lambda_enhanced, top_n=6)

            lines.append("üéØ –ü–†–û–ì–ù–û–ó –¢–û–ß–ù–û–ì–û –°–ß–ï–¢–ê:")
            lines.append("   –¢–æ–ø-6 –Ω–∞–∏–±–æ–ª–µ–µ –≤–µ—Ä–æ—è—Ç–Ω—ã—Ö —Å—á–µ—Ç–æ–≤:")
            for i, ((h, a), prob) in enumerate(top_scores_lambda, 1):
                lines.append(f"   {i}. {h}:{a} - {prob:.2f}%")
            lines.append("")

            lines.append("üí° –†–ï–ö–û–ú–ï–ù–î–ê–¶–ò–Ø –ü–û –¢–û–ß–ù–û–ú–£ –°–ß–ï–¢–£:")
            lambda_exact_recommendation = self._get_exact_score_recommendation(top_scores_lambda)
            for line in lambda_exact_recommendation.split('\n'):
                lines.append(f"   {line}")
            lines.append("")

            # –î–æ–±–∞–≤–ª—è–µ–º –∞–Ω–∞–ª–∏–∑ —É–≥–ª–æ–≤—ã—Ö –¥–ª—è Œª-–∞–ª–≥–æ—Ä–∏—Ç–º–∞
            corners_analysis_lambda = get_detailed_corners_analysis(
                team1_data, team2_data, is_home_team1=True, confidence_level=conf
            )
            corners_lines_lambda = format_corners_analysis_for_display(corners_analysis_lambda)
            lines.extend(corners_lines_lambda)
            lines.append("")

        # --- –°–†–ê–í–ù–ï–ù–ò–ï –ê–õ–ì–û–†–ò–¢–ú–û–í ---
        if algorithm == "both":
            lines.append("=" * 80)
            lines.append("üé≠ –°–†–ê–í–ù–ï–ù–ò–ï –ê–õ–ì–û–†–ò–¢–ú–û–í")
            lines.append("=" * 80)

            # –°—Ä–∞–≤–Ω–µ–Ω–∏–µ —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–π
            trad_pick = "–ü1" if p1g > p2g and p1g > pd else ("–ü2" if p2g > p1g and p2g > pd else "–ù–∏—á—å—è/X")
            lambda_pick = lambda_recommended

            lines.append("üìä –°–û–í–ü–ê–î–ï–ù–ò–ï –†–ï–ö–û–ú–ï–ù–î–ê–¶–ò–ô:")
            if trad_pick == lambda_pick:
                lines.append(f"‚úÖ –û–ë–ê –∞–ª–≥–æ—Ä–∏—Ç–º–∞ —Ä–µ–∫–æ–º–µ–Ω–¥—É—é—Ç: {trad_pick}")
                lines.append(
                    f"   ‚Ä¢ –¢—Ä–∞–¥–∏—Ü–∏–æ–Ω–Ω—ã–π (—á–∏—Å—Ç—ã–µ –¥–∞–Ω–Ω—ã–µ): –ü1={p1g * 100:.1f}% | –ù={pd * 100:.1f}% | –ü2={p2g * 100:.1f}%")
                lines.append(
                    f"   ‚Ä¢ Œª-–∞–ª–≥–æ—Ä–∏—Ç–º (—É–ª—É—á—à–µ–Ω–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ): –ü1={p1g_lambda * 100:.1f}% | –ù={pd_lambda * 100:.1f}% | –ü2={p2g_lambda * 100:.1f}%")
            else:
                lines.append(f"‚ö†Ô∏è  –†–ê–ó–ù–´–ï —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏:")
                lines.append(f"   ‚Ä¢ –¢—Ä–∞–¥–∏—Ü–∏–æ–Ω–Ω—ã–π (—á–∏—Å—Ç—ã–µ): {trad_pick} ({max(p1g, pd, p2g) * 100:.1f}%)")
                lines.append(
                    f"   ‚Ä¢ Œª-–∞–ª–≥–æ—Ä–∏—Ç–º (—É–ª—É—á—à–µ–Ω–Ω—ã–µ): {lambda_pick} ({max(p1g_lambda, pd_lambda, p2g_lambda) * 100:.1f}%)")

            lines.append("")
            lines.append("üìà –°–†–ê–í–ù–ï–ù–ò–ï XG:")
            lines.append(
                f"   ‚Ä¢ –¢—Ä–∞–¥–∏—Ü–∏–æ–Ω–Ω—ã–π (—á–∏—Å—Ç—ã–µ): –ö1={xg1_trad:.2f} | –ö2={xg2_trad:.2f} | –í—Å–µ–≥–æ={xg1_trad + xg2_trad:.2f}")
            lines.append(
                f"   ‚Ä¢ Œª-–∞–ª–≥–æ—Ä–∏—Ç–º (—É–ª—É—á—à–µ–Ω–Ω—ã–µ): –ö1={xg1_lambda_enhanced:.2f} | –ö2={xg2_lambda_enhanced:.2f} | –í—Å–µ–≥–æ={xg1_lambda_enhanced + xg2_lambda_enhanced:.2f}")
            lines.append(
                f"   ‚Ä¢ –†–∞–∑–Ω–∏—Ü–∞: –ö1={xg1_lambda_enhanced - xg1_trad:+.2f} | –ö2={xg2_lambda_enhanced - xg2_trad:+.2f}")
            lines.append("")

            lines.append("üí° –û–ë–û–°–ù–û–í–ê–ù–ò–ï –ò–¢–û–ì–û–í–û–ô –†–ï–ö–û–ú–ï–ù–î–ê–¶–ò–ò:")

            # –ò—Ç–æ–≥–æ–≤–∞—è —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏—è —Å –∫—Ä–∞—Ç–∫–∏–º –æ–±–æ—Å–Ω–æ–≤–∞–Ω–∏–µ–º
            lines.append("")
            lines.append("üèÜ –ò–¢–û–ì–û–í–ê–Ø –†–ï–ö–û–ú–ï–ù–î–ê–¶–ò–Ø:")

            if trad_pick == lambda_pick:
                if trad_pick == "–ü1":
                    lines.append(
                        f"   ‚úÖ –ü1 - {get_final_recommendation_text(trad_pick, p1g * 100, team1_quality, team2_quality, True)}")
                    lines.append(f"   üéØ –û—Å–Ω–æ–≤–∞–Ω–æ –Ω–∞ —Å–æ–≤–ø–∞–¥–µ–Ω–∏–∏ –æ–±–æ–∏—Ö –∞–ª–≥–æ—Ä–∏—Ç–º–æ–≤")
                elif trad_pick == "–ü2":
                    lines.append(
                        f"   ‚úÖ –ü2 - {get_final_recommendation_text(trad_pick, p2g * 100, team1_quality, team2_quality, False)}")
                    lines.append(f"   üéØ –û—Å–Ω–æ–≤–∞–Ω–æ –Ω–∞ —Å–æ–≤–ø–∞–¥–µ–Ω–∏–∏ –æ–±–æ–∏—Ö –∞–ª–≥–æ—Ä–∏—Ç–º–æ–≤")
                else:
                    lines.append(
                        f"   ‚úÖ –ù–∏—á—å—è - {get_final_recommendation_text('–ù–∏—á—å—è', pd * 100, team1_quality, team2_quality, False)}")
                    lines.append(f"   üéØ –û—Å–Ω–æ–≤–∞–Ω–æ –Ω–∞ —Å–æ–≤–ø–∞–¥–µ–Ω–∏–∏ –æ–±–æ–∏—Ö –∞–ª–≥–æ—Ä–∏—Ç–º–æ–≤")
            else:
                # –í—ã–±–∏—Ä–∞–µ–º –∞–ª–≥–æ—Ä–∏—Ç–º —Å –±–æ–ª—å—à–µ–π —É–≤–µ—Ä–µ–Ω–Ω–æ—Å—Ç—å—é
                trad_confidence = max(p1g, pd, p2g)
                lambda_confidence = max(p1g_lambda, pd_lambda, p2g_lambda)

                if lambda_confidence > trad_confidence:
                    lines.append(
                        f"   üî¨ –ü—Ä–µ–¥–ø–æ—á—Ç–µ–Ω–∏–µ Œª-–∞–ª–≥–æ—Ä–∏—Ç–º—É (–≤—ã—à–µ —É–≤–µ—Ä–µ–Ω–Ω–æ—Å—Ç—å: {lambda_confidence * 100:.1f}% vs {trad_confidence * 100:.1f}%)")
                    if lambda_pick == "–ü1":
                        lines.append(
                            f"   üìà –ü1 - {get_final_recommendation_text(lambda_pick, p1g_lambda * 100, team1_quality, team2_quality, True)}")
                    elif lambda_pick == "–ü2":
                        lines.append(
                            f"   üìà –ü2 - {get_final_recommendation_text(lambda_pick, p2g_lambda * 100, team1_quality, team2_quality, False)}")
                    else:
                        lines.append(
                            f"   üìà –ù–∏—á—å—è - {get_final_recommendation_text('–ù–∏—á—å—è', pd_lambda * 100, team1_quality, team2_quality, False)}")
                else:
                    lines.append(
                        f"   üî¨ –ü—Ä–µ–¥–ø–æ—á—Ç–µ–Ω–∏–µ —Ç—Ä–∞–¥–∏—Ü–∏–æ–Ω–Ω–æ–º—É –∞–ª–≥–æ—Ä–∏—Ç–º—É (–≤—ã—à–µ —É–≤–µ—Ä–µ–Ω–Ω–æ—Å—Ç—å: {trad_confidence * 100:.1f}% vs {lambda_confidence * 100:.1f}%)")
                    if trad_pick == "–ü1":
                        lines.append(
                            f"   üìà –ü1 - {get_final_recommendation_text(trad_pick, p1g * 100, team1_quality, team2_quality, False)}")
                    elif trad_pick == "–ü2":
                        lines.append(
                            f"   üìà –ü2 - {get_final_recommendation_text(trad_pick, p2g * 100, team1_quality, team2_quality, False)}")
                    else:
                        lines.append(
                            f"   üìà –ù–∏—á—å—è - {get_final_recommendation_text('–ù–∏—á—å—è', pd * 100, team1_quality, team2_quality, False)}")

        elif algorithm == "traditional":
            lines.append("=" * 80)
            lines.append("‚úÖ –ò–¢–û–ì–û–í–ê–Ø –†–ï–ö–û–ú–ï–ù–î–ê–¶–ò–Ø (–¢–†–ê–î–ò–¶–ò–û–ù–ù–´–ô - –ß–ò–°–¢–´–ï –î–ê–ù–ù–´–ï)")
            lines.append("=" * 80)
            if pick_match == "–ü1":
                lines.append(
                    f"üéØ –ü1 - {get_final_recommendation_text('–ü1', p1g * 100, team1_quality, team2_quality, False)}")
            elif pick_match == "–ü2":
                lines.append(
                    f"üéØ –ü2 - {get_final_recommendation_text('–ü2', p2g * 100, team1_quality, team2_quality, False)}")
            else:
                lines.append(
                    f"üéØ –ù–∏—á—å—è - {get_final_recommendation_text('–ù–∏—á—å—è', pd * 100, team1_quality, team2_quality, False)}")

        elif algorithm == "lambda":
            lines.append("=" * 80)
            lines.append("‚úÖ –ò–¢–û–ì–û–í–ê–Ø –†–ï–ö–û–ú–ï–ù–î–ê–¶–ò–Ø (Œª-–ê–õ–ì–û–†–ò–¢–ú - –£–õ–£–ß–®–ï–ù–ù–´–ï –î–ê–ù–ù–´–ï)")
            lines.append("=" * 80)
            if lambda_recommended == "–ü1":
                lines.append(
                    f"üéØ –ü1 - {get_final_recommendation_text('–ü1', p1g_lambda * 100, team1_quality, team2_quality, True)}")
            elif lambda_recommended == "–ü2":
                lines.append(
                    f"üéØ –ü2 - {get_final_recommendation_text('–ü2', p2g_lambda * 100, team1_quality, team2_quality, False)}")
            else:
                lines.append(
                    f"üéØ –ù–∏—á—å—è - {get_final_recommendation_text('–ù–∏—á—å—è', pd_lambda * 100, team1_quality, team2_quality, False)}")

        lines.append(f"üìÖ –ê–Ω–∞–ª–∏–∑ –≤—ã–ø–æ–ª–Ω–µ–Ω: {time.strftime('%d.%m.%Y %H:%M:%S')}")

        out_text = "\n".join(lines)
        self.output.configure(state="normal")
        self.output.delete("1.0", "end")
        self.output.insert("1.0", out_text)
        self.output.configure(state="disabled")

    def on_reset(self):
        """–°–±—Ä–æ—Å –≤—Å–µ—Ö –ø–æ–ª–µ–π –≤–≤–æ–¥–∞"""
        for row in self.team1_entries + self.team2_entries:
            for k, v in row.items():
                try:
                    v.delete(0, 'end')
                except Exception:
                    pass
        self.output.configure(state="normal")
        self.output.delete("1.0", "end")
        self.output.configure(state="disabled")

    def on_save(self):
        """–°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤ –∞–Ω–∞–ª–∏–∑–∞"""
        output_text = self.output.get("1.0", "end").strip()

        if not output_text:
            messagebox.showwarning("–ü—É—Å—Ç–æ", "–ù–µ—Ç –¥–∞–Ω–Ω—ã—Ö –¥–ª—è —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è. –ù–∞–∂–º–∏—Ç–µ '–†–∞—Å—Å—á–∏—Ç–∞—Ç—å'.")
            return

        full_text = output_text

        desktop = os.path.join(os.path.expanduser("~"), "Desktop")
        try:
            os.makedirs(desktop, exist_ok=True)
        except Exception:
            desktop = os.path.expanduser("~")

        fname = f"–ü—Ä–æ–≥–Ω–æ–∑_–º–∞—Ç—á–∞_v2_{time.strftime('%Y%m%d_%H%M%S')}.txt"
        path = filedialog.asksaveasfilename(
            initialfile=os.path.join(desktop, fname),
            defaultextension=".txt",
            filetypes=[("–¢–µ–∫—Å—Ç–æ–≤—ã–µ —Ñ–∞–π–ª—ã", "*.txt"), ("–í—Å–µ —Ñ–∞–π–ª—ã", "*.*")],
            title="–°–æ—Ö—Ä–∞–Ω–∏—Ç—å –æ—Ç—á–µ—Ç –∞–Ω–∞–ª–∏–∑–∞"
        )

        if not path:
            return

        try:
            with open(path, "w", encoding="utf-8") as f:
                f.write(full_text)
            messagebox.showinfo("–°–æ—Ö—Ä–∞–Ω–µ–Ω–æ", f"–û—Ç—á–µ—Ç —É—Å–ø–µ—à–Ω–æ —Å–æ—Ö—Ä–∞–Ω–µ–Ω:\n{path}")
        except Exception as e:
            messagebox.showerror("–û—à–∏–±–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è", f"–ù–µ —É–¥–∞–ª–æ—Å—å —Å–æ—Ö—Ä–∞–Ω–∏—Ç—å —Ñ–∞–π–ª:\n{str(e)}")


if __name__ == "__main__":
    app = UltraCompactPredictor()
    app.mainloop()